<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#0a0e14">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Flashcards">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='20' fill='%23667eea'/%3E%3Ctext x='50' y='70' font-size='60' text-anchor='middle' fill='white'%3EðŸ“š%3C/text%3E%3C/svg%3E">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,wght@0,400;0,500;0,600;0,700;1,400&family=JetBrains+Mono:wght@400;500;600&family=Space+Grotesk:wght@500;600;700&display=swap" rel="stylesheet">
    <title>Language Flashcards</title>
    <style>
        :root {
            /* Dark industrial base palette */
            --bg-primary: #0a0e14;
            --bg-secondary: #121820;
            --bg-tertiary: #1a222d;
            --bg-card: #1e2732;
            --bg-card-hover: #252f3c;

            /* Text colors - high contrast */
            --text-primary: #ffffff;
            --text-secondary: #e0e4ea;
            --text-muted: #a0a8b4;

            /* Accent colors - industrial/energy */
            --accent-orange: #ff6b35;
            --accent-amber: #f5a623;
            --accent-blue: #4a9eff;
            --accent-green: #00d4aa;

            /* Language-specific theme colors (dynamically updated) */
            --accent-primary: #C8102E;
            --accent-secondary: #FFCC00;

            /* Semantic colors */
            --success: #00d4aa;
            --error: #ff5252;
            --warning: #f5a623;

            /* Borders and dividers */
            --border-color: #2a3441;
            --border-light: #3a4553;

            /* Glow effects */
            --glow-orange: rgba(255, 107, 53, 0.3);
            --glow-blue: rgba(74, 158, 255, 0.3);
            --glow-green: rgba(0, 212, 170, 0.3);

            /* Fonts */
            --font-reading: 'DM Sans', -apple-system, BlinkMacSystemFont, sans-serif;
            --font-emphasis: 'Space Grotesk', -apple-system, BlinkMacSystemFont, sans-serif;
            --font-data: 'JetBrains Mono', monospace;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-reading);
            background: var(--bg-primary);
            background-image:
                radial-gradient(ellipse at top, var(--bg-secondary) 0%, transparent 50%),
                radial-gradient(ellipse at bottom right, rgba(255, 107, 53, 0.05) 0%, transparent 40%);
            min-height: 100vh;
            height: 100vh;
            padding: 0;
            margin: 0;
            color: var(--text-primary);
            overflow: hidden;
            touch-action: manipulation;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
        }

        .container {
            max-width: 100%;
            width: 100%;
            height: 100%;
            margin: 0 auto;
            padding: 10px;
            box-sizing: border-box;
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
        }

        @media (min-width: 768px) {
            .container {
                max-width: 800px;
                padding: 20px;
            }
        }

        .header {
            text-align: center;
            color: white;
            padding: 20px 0;
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .mode-btn {
            flex: 1;
            min-width: 120px;
            padding: 12px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            color: var(--text-secondary);
        }

        .mode-btn:hover {
            transform: translateY(-2px);
            background: var(--bg-card-hover);
            border-color: var(--accent-primary);
        }

        .mode-btn.active {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-color: var(--accent-primary);
        }

        .card-container {
            perspective: 1000px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px 0;
            overflow: hidden;
            touch-action: pan-x pan-y;
            -webkit-user-select: none;
            user-select: none;
        }

        .card {
            width: 100%;
            height: auto;
            min-height: 460px;
            max-height: calc(100vh - 100px);
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            cursor: pointer;
            touch-action: none;
            -webkit-user-drag: none;
        }

        .card.swiping {
            transition: none;
        }

        .card.swipe-correct {
            animation: swipeRight 0.3s ease-out forwards;
        }

        .card.swipe-incorrect {
            animation: swipeLeft 0.3s ease-out forwards;
        }

        .card.flipped.swipe-correct {
            animation: swipeRightFlipped 0.3s ease-out forwards;
        }

        .card.flipped.swipe-incorrect {
            animation: swipeLeftFlipped 0.3s ease-out forwards;
        }

        @keyframes swipeRight {
            to {
                transform: translateX(150%) rotate(20deg);
                opacity: 0;
            }
        }

        @keyframes swipeLeft {
            to {
                transform: translateX(-150%) rotate(-20deg);
                opacity: 0;
            }
        }

        @keyframes swipeRightFlipped {
            to {
                transform: translateX(150%) rotate(20deg) rotateY(180deg);
                opacity: 0;
            }
        }

        @keyframes swipeLeftFlipped {
            to {
                transform: translateX(-150%) rotate(-20deg) rotateY(180deg);
                opacity: 0;
            }
        }

        @media (min-width: 768px) {
            .card {
                max-height: calc(100vh - 120px);
            }
        }

        .swipe-indicator {
            position: absolute;
            top: 50%;
            font-size: 72px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
            pointer-events: none;
            transform: translateY(-50%);
        }

        .swipe-indicator.correct {
            right: 20px;
            color: var(--accent-green);
            text-shadow: 0 0 20px var(--glow-green);
        }

        .swipe-indicator.incorrect {
            left: 20px;
            color: var(--error);
            text-shadow: 0 0 20px rgba(255, 82, 82, 0.5);
        }

        .swipe-indicator.visible {
            opacity: 1;
        }

        .card.flipped {
            transform: rotateY(180deg);
        }

        /* Hide front card controls when flipped */
        .card.flipped .card-front {
            visibility: hidden;
            opacity: 0;
            pointer-events: none;
        }

        .card.flipped .card-back {
            visibility: visible;
            opacity: 1;
            pointer-events: auto;
        }

        /* Ensure back is hidden when not flipped */
        .card-back {
            opacity: 0;
        }

        .card-front {
            visibility: visible;
            pointer-events: auto;
        }

        .card-back {
            visibility: hidden;
            pointer-events: none;
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 16px;
            padding: 30px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: var(--bg-card);
            box-shadow: 0 10px 40px rgba(0,0,0,0.4), 0 0 1px rgba(255, 107, 53, 0.1);
            overflow: hidden;
        }

        .card-face::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 16px;
            padding: 2px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary), var(--accent-primary));
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask-composite: exclude;
            pointer-events: none;
        }

        @media (max-width: 767px) {
            .card-face {
                padding: 20px;
            }
        }

        .card-back {
            transform: rotateY(180deg);
        }

        .card-word {
            font-family: var(--font-emphasis);
            font-size: 64px;
            font-weight: 700;
            margin-bottom: 20px;
            color: var(--accent-primary);
            text-align: center;
        }

        .card-lemma {
            font-family: var(--font-reading);
            font-size: 22px;
            color: var(--accent-secondary);
            text-align: center;
            margin-bottom: 15px;
            font-weight: 500;
        }

        .card-ranking {
            font-family: var(--font-data);
            font-size: 16px;
            color: var(--text-muted);
            text-align: center;
            letter-spacing: 0.5px;
        }

        .card-control-btn {
            padding: 8px 14px;
            background: #1a1a1a;
            color: var(--text-primary);
            border: 1.5px solid #333333;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 700;
            font-family: var(--font-emphasis);
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 50px;
            height: 38px;
            letter-spacing: 0.3px;
            text-transform: uppercase;
            transform-style: preserve-3d;
        }

        /* Prevent buttons from rotating with card flip */
        .card.flipped .card-front .card-control-btn,
        .card.flipped .card-front .nav-btn-inline,
        .card.flipped .card-front .card-action-small {
            transform: rotateY(-180deg);
            pointer-events: auto;
        }

        /* Ensure buttons are clickable */
        .card-control-btn,
        .nav-btn-inline,
        .card-action-small {
            pointer-events: auto;
            position: relative;
        }

        .card-control-btn:hover {
            background: #2a2a2a;
            border-color: #444444;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .card-control-btn:active {
            transform: scale(0.95);
            background: #0f0f0f;
        }

        .card-action-small {
            padding: 10px 34px;
            background: var(--bg-card);
            color: var(--text-muted);
            border: 1.5px solid #333333;
            border-radius: 6px;
            font-size: 17px;
            font-weight: 700;
            font-family: var(--font-emphasis);
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 128px;
            height: 46px;
            letter-spacing: 0.3px;
            text-transform: uppercase;
            transform-style: preserve-3d;
            white-space: nowrap;
            overflow: hidden;
        }

        .card-action-small:hover {
            background: #2a2a2a;
            border-color: #444444;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .card-action-small:active {
            transform: scale(0.95);
            background: #0f0f0f;
        }

        .card-details {
            font-family: var(--font-reading);
            font-size: 18px;
            line-height: 1.8;
            text-align: center;
            width: 100%;
            max-width: 100%;
            overflow-wrap: break-word;
            word-wrap: break-word;
            color: var(--text-primary);
        }

        @media (max-width: 767px) {
            .card-details {
                font-size: 16px;
            }
        }

        .card-details strong {
            color: var(--accent-secondary);
        }

        .sentence {
            margin-top: 15px;
            padding: 15px;
            background: rgba(var(--accent-primary-rgb), 0.08);
            border: 1px solid var(--accent-primary);
            border-left: 3px solid var(--accent-primary);
            border-radius: 8px;
            font-family: var(--font-reading);
            font-style: italic;
            font-size: 22px;
            overflow-wrap: break-word;
            word-wrap: break-word;
            text-align: center;
            color: #ffffff;
        }

        @media (max-width: 767px) {
            .sentence {
                font-size: 20px;
                padding: 12px;
            }
        }

        .translation {
            margin-top: 8px;
            color: var(--accent-secondary);
            font-size: 16px;
            font-weight: 500;
        }

        .links-section {
            margin-top: auto;
            padding-top: 15px;
            border-top: 1px solid var(--border-color);
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .link-btn {
            display: inline-block;
            padding: 8px 16px;
            background: var(--bg-tertiary);
            color: var(--accent-secondary);
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
            border: 1px solid var(--border-color);
            transition: all 0.3s;
        }

        .link-btn:hover {
            background: var(--accent-secondary);
            color: var(--bg-primary);
            border-color: var(--accent-secondary);
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            background: var(--bg-card);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }

        .nav-btn {
            padding: 12px 24px;
            background: var(--accent-primary);
            color: var(--bg-primary);
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .nav-btn:hover {
            box-shadow: 0 0 20px var(--glow-orange);
        }

        .nav-btn:disabled {
            background: var(--bg-tertiary);
            color: var(--text-muted);
            cursor: not-allowed;
        }

        #correctBtn:hover:not(:disabled) {
            box-shadow: 0 0 20px var(--glow-green);
        }

        #incorrectBtn:hover:not(:disabled) {
            box-shadow: 0 0 20px rgba(255, 82, 82, 0.5);
        }

        .nav-btn-inline {
            padding: 10px 14px;
            background: var(--bg-tertiary);
            color: var(--accent-secondary);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            font-size: 24px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 10;
            transform-style: preserve-3d;
        }

        .nav-btn-inline:hover {
            background: var(--accent-secondary);
            color: var(--bg-primary);
            border-color: var(--accent-secondary);
        }

        .nav-btn-inline:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .progress {
            text-align: center;
            font-weight: 600;
            color: var(--accent-secondary);
        }

        .action-btn {
            padding: 0;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 52px;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.15s ease-out, filter 0.15s ease-out;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        .action-btn:hover {
            transform: scale(1.1);
        }

        .action-btn:active {
            transform: scale(0.75);
            filter: brightness(0.8);
        }

        /* For touch devices - maintain pressed state while held */
        @media (hover: none) {
            .action-btn:active {
                transform: scale(0.7);
            }
        }

        .control-action-btn {
            padding: 10px 20px;
            background: #1a1a1a;
            color: var(--text-primary);
            border: 1.5px solid #333333;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 700;
            font-family: var(--font-emphasis);
            cursor: pointer;
            transition: all 0.3s;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        .control-action-btn:hover {
            background: #2a2a2a;
            border-color: #444444;
            box-shadow: 0 0 12px rgba(0, 0, 0, 0.5);
        }

        .control-action-btn:active {
            transform: scale(0.95);
            background: #0f0f0f;
        }

        .quiz-container {
            background: var(--bg-card);
            padding: 30px;
            border-radius: 16px;
            border: 1px solid var(--border-color);
            margin-bottom: 20px;
        }

        .quiz-question {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 25px;
            color: var(--accent-primary);
            text-align: center;
        }

        .quiz-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .quiz-option {
            padding: 15px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 16px;
            color: var(--text-primary);
        }

        .quiz-option:hover {
            background: var(--bg-card-hover);
            border-color: var(--accent-blue);
        }

        .quiz-option.correct {
            background: rgba(0, 212, 170, 0.15);
            border-color: var(--accent-green);
        }

        .quiz-option.incorrect {
            background: rgba(255, 82, 82, 0.15);
            border-color: var(--error);
        }

        .quiz-feedback {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-weight: 600;
        }

        .quiz-feedback.correct {
            background: rgba(0, 212, 170, 0.15);
            color: var(--accent-green);
        }

        .quiz-feedback.incorrect {
            background: rgba(255, 82, 82, 0.15);
            color: var(--error);
        }

        .type-container {
            background: var(--bg-card);
            padding: 30px;
            border-radius: 16px;
            border: 1px solid var(--border-color);
            margin-bottom: 20px;
        }

        .type-prompt {
            font-size: 20px;
            margin-bottom: 20px;
            color: var(--accent-primary);
            text-align: center;
        }

        .type-input {
            width: 100%;
            padding: 15px;
            font-size: 18px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 15px;
            color: var(--text-primary);
        }

        .type-input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .check-btn {
            width: 100%;
            padding: 15px;
            background: var(--accent-primary);
            color: var(--bg-primary);
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }

        .stats {
            background: var(--bg-card);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            margin-bottom: 20px;
        }

        .stats h3 {
            color: var(--accent-primary);
            margin-bottom: 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-secondary);
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .file-upload {
            background: transparent;
            padding: 10px;
            border-radius: 12px;
            margin-bottom: 20px;
            text-align: center;
        }

        .file-input {
            display: none;
        }

        .upload-btn {
            padding: 12px 24px;
            background: var(--accent-primary);
            color: var(--bg-primary);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
        }

        .hidden {
            display: none !important;
        }

        #appContent {
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
        }

        /* Setup Steps */
        .setup-step {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
        }

        .selected-language-inline {
            display: none;
            align-items: center;
            margin-top: 12px;
            padding: 10px 16px;
            background: var(--accent-primary);
            color: white;
            border-radius: 8px;
            font-family: var(--font-emphasis);
            font-weight: 600;
            font-size: 15px;
            opacity: 0;
            transform: translateY(-10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .selected-language-inline.visible {
            display: flex;
            opacity: 1;
            transform: translateY(0);
        }

        /* Loading state for data refresh */
        .data-loading-indicator {
            display: none;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 15px;
            color: var(--text-muted);
            font-size: 14px;
        }

        .data-loading-indicator.visible {
            display: flex;
        }

        .data-loading-indicator .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid var(--border-color);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .step-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 15px;
        }

        .step-number {
            font-family: var(--font-emphasis);
            width: 28px;
            height: 28px;
            background: var(--accent-secondary);
            color: var(--bg-primary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 14px;
        }

        .step-title {
            font-family: var(--font-emphasis);
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .level-selector {
            display: flex;
            flex-wrap: nowrap;
            gap: 0;
            justify-content: flex-start;
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 4px;
            overflow-x: auto;
            overflow-y: hidden;
            scrollbar-width: thin;
            scrollbar-color: var(--border-color) transparent;
        }

        .level-selector::-webkit-scrollbar {
            height: 6px;
        }

        .level-selector::-webkit-scrollbar-track {
            background: transparent;
        }

        .level-selector::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        .level-btn {
            flex: 0 0 auto;
            min-width: 60px;
            padding: 10px 14px;
            background: transparent;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            color: var(--text-muted);
        }

        .level-btn:hover {
            background: rgba(255, 107, 53, 0.1);
            color: var(--text-primary);
        }

        .level-btn.selected {
            background: var(--bg-card);
            color: var(--accent-primary);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .range-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .range-btn-new {
            font-family: var(--font-emphasis);
            padding: 10px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s;
            color: var(--text-muted);
            min-width: 81px;
        }

        .range-btn-new:hover {
            background: var(--accent-secondary);
            color: var(--bg-primary);
            border-color: var(--accent-secondary);
            box-shadow: 0 0 15px rgba(var(--accent-secondary-rgb, 255, 204, 0), 0.3);
            transform: translateY(-2px);
        }

        .range-btn-new.mastered {
            background: var(--accent-secondary);
            color: var(--bg-primary);
            border-color: var(--accent-secondary);
        }

        .range-btn-new.mastered:hover {
            background: var(--accent-secondary);
            color: var(--bg-primary);
            border-color: var(--accent-secondary);
            box-shadow: 0 0 15px rgba(var(--accent-secondary-rgb, 255, 204, 0), 0.3);
            transform: translateY(-2px);
        }

        .range-btn-new.attempted {
            background: rgba(var(--accent-secondary-rgb, 255, 204, 0), 0.15);
            border-color: rgba(var(--accent-secondary-rgb, 255, 204, 0), 0.4);
        }

        .range-btn-new.attempted:hover {
            background: rgba(var(--accent-secondary-rgb, 255, 204, 0), 0.25);
            border-color: rgba(var(--accent-secondary-rgb, 255, 204, 0), 0.6);
            transform: translateY(-2px);
        }

        .range-btn-new:active {
            transform: scale(0.95);
        }

        .range-btn-new.disabled,
        .range-btn-new:disabled {
            background: var(--bg-secondary);
            color: var(--text-muted);
            border-color: var(--border-color);
            cursor: not-allowed;
            opacity: 0.35;
            pointer-events: none;
        }

        .range-btn-new.disabled:hover,
        .range-btn-new:disabled:hover {
            background: var(--bg-secondary);
            color: var(--text-muted);
            border-color: var(--border-color);
            box-shadow: none;
            transform: none;
            cursor: not-allowed;
            pointer-events: none;
        }

        .range-btn-new.disabled:active,
        .range-btn-new:disabled:active {
            transform: none;
            pointer-events: none;
        }

        .range-btn {
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            color: var(--text-secondary);
        }

        .range-btn:hover {
            background: var(--bg-card-hover);
            border-color: var(--accent-primary);
        }

        .range-btn.selected {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-color: var(--accent-primary);
        }

        .language-tabs {
            display: flex;
            gap: 0;
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 4px;
            overflow-x: auto;
            overflow-y: hidden;
            scrollbar-width: thin;
            scrollbar-color: var(--border-color) transparent;
        }

        .language-tabs::-webkit-scrollbar {
            height: 6px;
        }

        .language-tabs::-webkit-scrollbar-track {
            background: transparent;
        }

        .language-tabs::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        .lang-tab {
            flex: 0 0 auto;
            min-width: 60px;
            padding: 10px 14px;
            background: transparent;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            color: var(--text-muted);
        }

        .lang-tab.active {
            background: var(--bg-card);
            color: var(--accent-primary);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .lang-tab.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            position: relative;
        }

        .lang-tab.disabled:hover {
            background: transparent;
            color: var(--text-muted);
        }

        .cefr-card {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.3s;
        }

        .cefr-card:hover {
            transform: translateY(-2px);
            border-color: var(--accent-primary);
            box-shadow: 0 4px 20px rgba(255, 107, 53, 0.15);
        }

        .cefr-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .cefr-level {
            font-family: var(--font-emphasis);
            font-size: 24px;
            font-weight: 700;
            color: var(--accent-primary);
        }

        .cefr-description {
            font-size: 14px;
            color: var(--text-muted);
        }

        .cefr-stats {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            font-size: 14px;
            color: var(--text-secondary);
        }

        .cefr-stats strong {
            color: var(--accent-secondary);
        }

        .cefr-ranges {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--border-color);
            display: none;
        }

        .cefr-card.expanded .cefr-ranges {
            display: block;
        }

        .cefr-ranges-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .cefr-range-btn {
            font-family: var(--font-emphasis);
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s;
            color: var(--text-secondary);
        }

        .cefr-range-btn:hover {
            background: var(--bg-card-hover);
            border-color: var(--accent-blue);
        }

        .cefr-range-btn.selected {
            background: var(--accent-blue);
            color: var(--bg-primary);
            border-color: var(--accent-blue);
            box-shadow: 0 0 10px var(--glow-blue);
        }

        .preset-size-btn {
            padding: 10px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            color: var(--text-secondary);
        }

        .preset-size-btn:hover {
            background: var(--bg-card-hover);
            border-color: var(--accent-primary);
        }

        .preset-size-btn.selected {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-color: var(--accent-primary);
        }

        .group-size-selector {
            display: flex;
            gap: 0;
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 4px;
            overflow-x: auto;
            overflow-y: hidden;
            scrollbar-width: thin;
            scrollbar-color: var(--border-color) transparent;
            justify-content: center;
        }

        .group-size-selector::-webkit-scrollbar {
            height: 6px;
        }

        .group-size-selector::-webkit-scrollbar-track {
            background: transparent;
        }

        .group-size-selector::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        .group-size-btn {
            font-family: var(--font-emphasis);
            flex: 0 0 auto;
            padding: 10px 12px;
            background: transparent;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            min-width: 46px;
            color: var(--text-muted);
        }

        .group-size-btn:hover {
            background: rgba(255, 107, 53, 0.1);
            color: var(--text-primary);
        }

        .group-size-btn.selected {
            background: var(--bg-card);
            color: var(--accent-primary);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .step-row {
            display: flex;
            gap: 15px;
            width: 100%;
        }

        .step-half {
            flex: 1;
            min-width: 0;
            max-width: 90%;
        }

        .step-half:first-child {
            flex: 0.9;
        }

        .step-half:last-child {
            flex: 1.1;
        }

        .step-half .step-header {
            margin-bottom: 10px;
        }

        .step-header-inline {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
        }

        .step-header-inline .step-header {
            margin-bottom: 0;
        }

        .step-header-inline .group-size-selector {
            margin-top: 0;
            flex-shrink: 0;
        }

        .lemma-toggle-btn {
            font-family: var(--font-emphasis);
            flex: 1;
            padding: 10px 10px;
            background: transparent;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            min-width: 38px;
            color: var(--text-muted);
        }

        .lemma-toggle-btn:hover {
            background: rgba(255, 107, 53, 0.1);
            color: var(--text-primary);
        }

        .lemma-toggle-btn.selected {
            background: var(--bg-card);
            color: var(--accent-primary);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .lemma-toggle-btn.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            pointer-events: none;
        }

        .lemma-toggle-unavailable .lemma-toggle-btn[data-lemma="on"] {
            opacity: 0.4;
            cursor: not-allowed;
            pointer-events: none;
        }

        .step-help-btn {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--accent-secondary);
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            margin-left: 4px;
            flex-shrink: 0;
        }

        .step-help-btn:hover {
            background: var(--accent-secondary);
            color: var(--bg-primary);
            border-color: var(--accent-secondary);
        }

        .incorrect-set-btn {
            font-family: var(--font-emphasis);
            padding: 10px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s;
            color: var(--text-muted);
            display: none;
            margin-left: auto;
            min-width: 81px;
        }

        .incorrect-set-btn.visible {
            display: inline-block;
        }

        .incorrect-set-btn:hover {
            background: var(--accent-secondary);
            color: var(--bg-primary);
            border-color: var(--accent-secondary);
            box-shadow: 0 0 15px rgba(var(--accent-secondary-rgb, 255, 204, 0), 0.3);
            transform: translateY(-2px);
        }

        .incorrect-set-btn:disabled {
            background: var(--bg-secondary);
            color: var(--text-muted);
            border-color: var(--border-color);
            cursor: not-allowed;
            opacity: 0.35;
            pointer-events: none;
        }

        .step-info-tooltip {
            display: none;
            position: absolute;
            top: calc(100% + 8px);
            left: 0;
            right: 0;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            font-size: 13px;
            line-height: 1.5;
            color: var(--text-secondary);
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .step-info-tooltip.visible {
            display: block;
        }

        .step-info-tooltip p {
            margin: 0 0 8px 0;
        }

        .step-info-tooltip p:last-child {
            margin-bottom: 0;
        }

        .step-info-tooltip strong {
            color: var(--accent-primary);
        }

        .step-header-with-help {
            position: relative;
            display: flex;
            align-items: center;
        }

        .cefr-actions {
            display: none;
            margin-top: 15px;
            gap: 10px;
            justify-content: space-between;
        }

        .cefr-card.expanded .cefr-actions {
            display: flex;
        }

        .start-level-btn {
            flex: 1;
            padding: 12px;
            background: var(--accent-green);
            color: var(--bg-primary);
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .start-level-btn:hover {
            box-shadow: 0 0 20px var(--glow-green);
        }

        .start-level-btn:disabled {
            background: var(--bg-tertiary);
            color: var(--text-muted);
            cursor: not-allowed;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal:not(.hidden) {
            display: flex;
        }

        .modal-content {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            border: 1px solid var(--border-color);
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }

        .modal-header h3 {
            font-family: var(--font-emphasis);
            color: var(--accent-primary);
            margin: 0;
            font-size: 24px;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: var(--text-muted);
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            color: var(--accent-primary);
        }

        .stats-body {
            margin-top: 15px;
        }

        .settings-tabs-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 15px;
        }

        .settings-tabs {
            display: flex;
            gap: 0;
            flex: 1;
        }

        .settings-tab {
            background: transparent;
            border: none;
            padding: 12px 20px;
            color: var(--text-muted);
            font-family: var(--font-reading);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
            border-bottom: 2px solid transparent;
            margin-bottom: -1px;
        }

        .settings-tab:hover {
            color: var(--text-primary);
        }

        .settings-tab.active {
            color: var(--accent-primary);
            border-bottom-color: var(--accent-primary);
        }

        .settings-tabs-header .modal-close {
            position: relative;
            top: auto;
            right: auto;
            margin-right: 10px;
        }

        .settings-tab-content {
            display: none;
        }

        .settings-tab-content.active {
            display: block;
        }

        .tap-hint {
            text-align: center;
            color: var(--text-muted);
            font-size: 14px;
            margin-top: 10px;
            font-style: italic;
        }

        .flip-circle {
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 60px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
        }

        .flip-circle:hover {
            border-color: rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.02);
        }

        .flip-circle:active {
            transform: scale(0.98);
        }

        .flip-back-area {
            display: inline-block;
            padding: 20px 40px;
            border: 2px solid rgba(255, 255, 255, 0);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .flip-back-area:hover {
            border-color: rgba(255, 255, 255, 0.15);
            background: rgba(255, 255, 255, 0.02);
        }

        .flip-back-area:active {
            transform: scale(0.98);
        }

        #flipBtn {
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        #flipBtn:focus {
            outline: none !important;
            box-shadow: none !important;
        }

        #flipBtn:active {
            opacity: 0.8;
        }

        /* Meaning boxes styles */
        .meanings-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            margin: 15px 0;
            width: 100%;
        }

        .meaning-box {
            padding: 10px 16px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            min-width: 80px;
            position: relative;
        }

        .meaning-box:hover {
            transform: translateY(-2px);
            border-color: var(--accent-blue);
        }

        .meaning-box.selected {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            transform: scale(1.05);
        }

        .meaning-box.selected .meaning-text {
            color: var(--bg-primary);
        }

        .meaning-box.selected .meaning-pos {
            color: var(--bg-primary);
            opacity: 0.8;
        }

        .meaning-text {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .meaning-pos {
            font-size: 11px;
            color: var(--accent-secondary);
            margin-top: 4px;
            font-family: var(--font-data);
            text-transform: uppercase;
        }

        .meaning-percent {
            position: absolute;
            top: -8px;
            right: -8px;
            background: var(--accent-secondary);
            color: var(--bg-primary);
            font-size: 10px;
            font-weight: 700;
            padding: 2px 6px;
            border-radius: 10px;
            font-family: var(--font-data);
        }

        /* Deck Complete Modal Styles */
        .deck-complete-body {
            padding: 10px 0;
        }

        .deck-complete-stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 15px;
        }

        .deck-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px 25px;
            border-radius: 12px;
            min-width: 90px;
        }

        .deck-stat.correct-stat {
            background: rgba(0, 212, 170, 0.15);
            color: var(--accent-green);
            border: 1px solid var(--accent-green);
        }

        .deck-stat.incorrect-stat {
            background: rgba(255, 82, 82, 0.15);
            color: var(--error);
            border: 1px solid var(--error);
        }

        .deck-stat-emoji {
            font-size: 28px;
            margin-bottom: 5px;
        }

        .deck-stat span:last-child {
            font-size: 24px;
            font-weight: bold;
        }

        .deck-complete-actions {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
        }

        .deck-complete-btn {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 16px 12px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            gap: 8px;
        }

        .deck-complete-btn .btn-icon {
            font-size: 24px;
        }

        .deck-complete-btn.restart-btn {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }

        .deck-complete-btn.restart-btn:hover {
            background: var(--bg-card-hover);
            border-color: var(--accent-secondary);
        }

        .deck-complete-btn.continue-btn {
            background: var(--accent-blue);
            color: var(--bg-primary);
        }

        .deck-complete-btn.continue-btn:hover {
            box-shadow: 0 0 20px var(--glow-blue);
        }

        .deck-complete-btn.continue-btn:disabled {
            background: var(--bg-tertiary);
            color: var(--text-muted);
            cursor: not-allowed;
        }

        .deck-complete-btn.mark-complete-btn {
            width: 100%;
            background: var(--accent-green);
            color: var(--bg-primary);
            flex-direction: row;
            gap: 10px;
        }

        .deck-complete-btn.mark-complete-btn:hover {
            box-shadow: 0 0 20px var(--glow-green);
        }

        /* Authentication Modal Styles */
        .auth-body {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .auth-btn {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 20px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: var(--font-reading);
            font-size: 16px;
            color: var(--text-primary);
            text-align: left;
            width: 100%;
        }

        .auth-btn:hover {
            border-color: var(--accent-primary);
            background: var(--bg-card-hover);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .auth-btn .btn-icon {
            font-size: 32px;
            flex-shrink: 0;
        }

        .auth-btn-content {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .auth-btn-title {
            font-weight: 600;
            font-size: 18px;
            color: var(--text-primary);
        }

        .auth-btn-desc {
            font-size: 14px;
            color: var(--text-muted);
        }

        .login-form {
            margin-top: 10px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
        }

        .login-form.hidden {
            display: none;
        }

        .initials-input {
            width: 100%;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: var(--font-emphasis);
            font-size: 18px;
            text-transform: uppercase;
            text-align: center;
            letter-spacing: 2px;
            margin-bottom: 15px;
        }

        .initials-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(200, 16, 46, 0.1);
        }

        .login-form-actions {
            display: flex;
            gap: 10px;
        }

        .auth-submit-btn, .auth-cancel-btn {
            flex: 1;
            padding: 12px 20px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-family: var(--font-emphasis);
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .auth-submit-btn {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }

        .auth-submit-btn:hover {
            box-shadow: 0 0 20px rgba(200, 16, 46, 0.3);
            transform: translateY(-2px);
        }

        .auth-submit-btn:disabled {
            background: var(--bg-tertiary);
            color: var(--text-muted);
            border-color: var(--border-color);
            cursor: not-allowed;
            transform: none;
        }

        .auth-cancel-btn {
            background: transparent;
            color: var(--text-secondary);
        }

        .auth-cancel-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--accent-secondary);
        }

        /* User Display */
        .user-info {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 16px;
            background: var(--bg-card);
            padding: 14px 36px;
            border-radius: 30px;
            border: 1px solid var(--border-color);
            font-family: var(--font-emphasis);
            font-size: 17px;
            z-index: 100;
        }

        .user-badge {
            color: var(--accent-primary);
            font-weight: 600;
            letter-spacing: 1px;
            font-size: 18px;
        }

        .logout-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-muted);
            padding: 8px 20px;
            border-radius: 16px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: var(--font-reading);
        }

        .logout-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border-color: var(--accent-primary);
        }

        .floating-btns {
            display: none;
            gap: 10px;
            margin-right: 12px;
            align-items: center;
        }

        .floating-btns.visible {
            display: flex !important;
        }

        .gear-btn {
            background: transparent;
            border: none;
            color: var(--text-muted);
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .gear-btn:hover {
            color: var(--accent-primary);
        }

        .gear-btn svg {
            width: 26px;
            height: 26px;
        }

        @media (max-width: 767px) {
            .user-info {
                top: 10px;
                right: 10px;
                padding: 12px 28px;
                font-size: 15px;
                gap: 14px;
            }

            .user-badge {
                font-size: 16px;
            }

            .logout-btn {
                padding: 6px 16px;
                font-size: 13px;
            }

            .gear-btn {
                padding: 8px;
            }

            .gear-btn svg {
                width: 24px;
                height: 24px;
            }
        }

        @media (max-width: 767px) {
            .card {
                height: calc(100vh - 180px);
                min-height: 460px;
                max-height: 633px;
            }

            .card-word {
                font-size: 48px;
            }

            .action-btn {
                font-size: 38px;
            }

            /* Mobile card front layout adjustments */
            .mobile-nav-row {
                display: flex !important;
            }
            .desktop-nav-row {
                display: none !important;
            }
        }

        @media (min-width: 768px) {
            .mobile-nav-row {
                display: none !important;
            }
            .desktop-nav-row {
                display: flex !important;
            }
        }

        /* Small pill button style (like logout) */
        .card-btn-pill {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-muted);
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: var(--font-reading);
        }

        .card-btn-pill:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border-color: var(--accent-primary);
        }

        .card-btn-pill svg {
            width: 14px;
            height: 14px;
            vertical-align: middle;
        }
    </style>
</head>
<body>
    <!-- User Info Display -->
    <div id="userInfo" class="user-info hidden">
        <!-- Floating buttons (shown only during flashcard view) -->
        <div id="floatingBtns" class="floating-btns">
            <button class="gear-btn" id="backBtnFloating" title="Back to menu">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="9 14 4 9 9 4"></polyline>
                    <path d="M20 20v-7a4 4 0 0 0-4-4H4"></path>
                </svg>
            </button>
            <button class="gear-btn" id="statsBtnFloating" title="View stats">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M18 20V10"></path>
                    <path d="M12 20V4"></path>
                    <path d="M6 20v-6"></path>
                </svg>
            </button>
        </div>
        <span class="user-badge" id="userBadge">GUEST</span>
        <button class="gear-btn" id="statsBtnPill" title="Stats" style="display: none;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M18 20V10"></path>
                <path d="M12 20V4"></path>
                <path d="M6 20v-6"></path>
            </svg>
        </button>
        <button class="gear-btn" id="gearBtn" title="Settings">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
            </svg>
        </button>
    </div>

    <div class="container">
        <div class="file-upload" id="setupPanel">
            <!-- Step 1: Language Selection -->
            <div id="step1" class="setup-step">
                <div class="step-header step-header-with-help" id="step1Header">
                    <span class="step-number">1</span>
                    <span class="step-title">Choose Language</span>
                    <button class="step-help-btn" data-tooltip="step1Tooltip" title="Help">?</button>
                    <div id="step1Tooltip" class="step-info-tooltip">
                        <p><strong>How to Study:</strong></p>
                        <p><strong>Tap card</strong> to flip and see translation</p>
                        <p><strong>Swipe right</strong> if you know the word âœ“</p>
                        <p><strong>Swipe left</strong> if you don't know it âœ—</p>
                        <p><strong>Words with multiple meanings:</strong> Swipe up/down on the back of the card to cycle through different definitions and their example sentences</p>
                        <p><strong>Arrow buttons</strong> to navigate cards manually</p>
                        <p><strong>Language button</strong> (top-left) switches direction between Target â†’ English and English â†’ Target</p>
                        <p><strong>At the end of each set</strong>, you'll see your accuracy and can review incorrect cards or continue to the next set</p>
                        <hr style="margin: 15px 0; border: none; border-top: 1px solid var(--border-color);">
                        <p><strong>Why Frequency Matters:</strong></p>
                        <p>Language follows a power law distribution: a small number of words account for the vast majority of everyday speech. Studies show that just 1,000 of the most common words make up approximately 80% of spoken language, while the top 3,000 words cover around 95% of typical conversations.</p>
                        <p>This app uses word frequency data derived from movie and TV subtitles, which represent natural, authentic language as it's actually spoken. By learning words ranked by how often they appear in real dialogue, you build practical fluency more efficiently than memorizing random vocabulary lists.</p>
                    </div>
                </div>
                <div class="language-tabs" id="languageTabs">
                    <!-- Language tabs will be dynamically generated -->
                </div>
                <div class="selected-language-inline" id="selectedLanguageInline">
                    <span id="selectedLanguageName"></span>
                </div>
            </div>

            <!-- Data Loading Indicator -->
            <div class="data-loading-indicator" id="dataLoadingIndicator">
                <div class="spinner"></div>
                <span>Loading your progress...</span>
            </div>

            <!-- Step 2: Level Selection -->
            <div id="step2" class="setup-step" style="display: none;">
                <div class="step-header step-header-with-help">
                    <span class="step-number">2</span>
                    <span class="step-title">Choose Level</span>
                    <button class="step-help-btn" data-tooltip="step2Tooltip" title="Help">?</button>
                    <div id="step2Tooltip" class="step-info-tooltip">
                        <p><strong>CEFR Levels</strong> indicate proficiency from beginner (A1) to proficient (C2).</p>
                        <p>Words are ranked by frequency. Lower levels cover the most common words needed for basic comprehension.</p>
                    </div>
                </div>
                <div id="levelSelector" class="level-selector"></div>
            </div>

            <!-- Step 3: Cards per Lemma -->
            <div id="lemmaToggleContainer" class="setup-step" style="display: none;">
                <div class="step-header-inline">
                    <div class="step-header step-header-with-help">
                        <span class="step-number">3</span>
                        <span class="step-title">Cards per Lemma</span>
                        <button class="step-help-btn" data-tooltip="step3Tooltip" title="Help">?</button>
                        <div id="step3Tooltip" class="step-info-tooltip">
                            <p><strong>Lemma</strong> = the base/dictionary form of a word.</p>
                            <p><strong>1</strong> = See only one card per lemma, skipping conjugations and declensions (e.g., "run" but not "runs", "ran", "running"). This reduces redundancy and focuses on learning root vocabulary.</p>
                            <p><strong>1+</strong> = See all forms including conjugations and declensions, which helps with recognition of different word forms in context.</p>
                        </div>
                    </div>
                    <div id="lemmaToggleSelector" class="group-size-selector">
                        <button class="lemma-toggle-btn" data-lemma="off">1+</button>
                        <button class="lemma-toggle-btn selected" data-lemma="on">1</button>
                    </div>
                </div>
            </div>

            <!-- Step 4: Cards per Set -->
            <div id="step3" class="setup-step" style="display: none;">
                <div class="step-header-inline">
                    <div class="step-header step-header-with-help">
                        <span class="step-number">4</span>
                        <span class="step-title">Cards per Set</span>
                        <button class="step-help-btn" data-tooltip="step4Tooltip" title="Help">?</button>
                        <div id="step4Tooltip" class="step-info-tooltip">
                            <p>Choose how many flashcards to study in each session.</p>
                            <p>Smaller sets (25) are good for quick review. Larger sets (50) for more intensive study.</p>
                        </div>
                    </div>
                    <div id="groupSizeSelector" class="group-size-selector">
                        <button class="group-size-btn selected" data-size="25">25</button>
                        <button class="group-size-btn" data-size="50">50</button>
                    </div>
                </div>
            </div>

            <!-- Step 5: Range Selection -->
            <div id="step4" class="setup-step" style="display: none;">
                <div class="step-header step-header-with-help">
                    <span class="step-number" id="rangeStepNumber">5</span>
                    <span class="step-title">Choose Set</span>
                    <button class="step-help-btn" data-tooltip="step5Tooltip" title="Help">?</button>
                    <button class="incorrect-set-btn" id="incorrectSetBtn" title="Study words you've previously marked incorrect">All Incorrect</button>
                    <div id="step5Tooltip" class="step-info-tooltip">
                        <p>Each set contains words ranked by frequency (e.g., 1-25 = most common words).</p>
                        <p><strong>Example sentences</strong> are designed to use words from nearby ranks (within ~20 positions), so practicing set 1-25 means sentences mostly use words from that same group.</p>
                        <p><strong>Incorrect</strong> button (when visible) lets you study all words you've previously marked wrong, ordered by least recently answered correctly.</p>
                    </div>
                </div>
                <div id="rangeSelector" class="range-selector"></div>
            </div>

            <div id="loadingMessage" style="margin-top: 20px; color: var(--accent-green); display: none; text-align: center; font-weight: 600;"></div>
        </div>

        <div id="appContent" class="hidden">
            <!-- Flashcard Mode -->
            <div id="flashcardMode">
                <div class="card-container">
                    <div class="swipe-indicator incorrect" id="incorrectIndicator">âœ—</div>
                    <div class="swipe-indicator correct" id="correctIndicator">âœ“</div>
                    <div class="card" id="flashcard" data-rank="">
                        <div class="card-face card-front">
                            <!-- Top row: REVERSE, STATS, SETTINGS, SHUFFLE -->
                            <div style="position: absolute; top: 20px; left: 20px; right: 20px; z-index: 5; pointer-events: none; display: flex; justify-content: space-between; align-items: center;">
                                <div style="display: flex; gap: 8px; pointer-events: auto;">
                                    <button class="card-action-small" id="reverseLangBtn" title="Reverse language direction">REVERSE</button>
                                </div>
                                <div style="display: flex; gap: 8px; pointer-events: auto;">
                                    <button class="card-action-small" id="shuffleBtnTop" title="Shuffle">
                                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                            <polyline points="16 3 21 3 21 8"></polyline>
                                            <line x1="4" y1="20" x2="21" y2="3"></line>
                                            <polyline points="21 16 21 21 16 21"></polyline>
                                            <line x1="15" y1="15" x2="21" y2="21"></line>
                                            <line x1="4" y1="4" x2="9" y2="9"></line>
                                        </svg>
                                    </button>
                                </div>
                            </div>
                            <button id="flipBtn" style="background: transparent; border: none; cursor: pointer; outline: none; padding: 60px; border-radius: 50%; width: 100%; z-index: 1;">
                                <div class="card-word" id="frontWord"></div>
                                <div class="card-lemma" id="frontLemma"></div>
                                <div class="card-ranking" id="frontRanking"></div>
                            </button>
                            <!-- Desktop: Left/right nav buttons beside the word -->
                            <div class="desktop-nav-row" style="display: flex; justify-content: space-between; align-items: center; width: 100%; position: absolute; top: 50%; transform: translateY(-50%); left: 0; padding: 0 20px; z-index: 5; pointer-events: none;">
                                <button class="nav-btn-inline" id="prevBtnFront" style="pointer-events: auto;">â†</button>
                                <button class="nav-btn-inline" id="nextBtnFront" style="pointer-events: auto;">â†’</button>
                            </div>
                            <!-- Mobile: Bottom row with arrows and speaker -->
                            <div class="mobile-nav-row" style="display: none; position: absolute; bottom: 20px; left: 20px; right: 20px; z-index: 5; pointer-events: none; justify-content: space-between; align-items: center;">
                                <button class="nav-btn-inline" id="prevBtnFrontMobile" style="pointer-events: auto;">â†</button>
                                <button class="nav-btn-inline" id="speakBtnMobile" title="Speak word" style="pointer-events: auto;">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                        <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                                        <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                                    </svg>
                                </button>
                                <button class="nav-btn-inline" id="nextBtnFrontMobile" style="pointer-events: auto;">â†’</button>
                            </div>
                            <!-- Desktop: Speaker button on bottom right -->
                            <div class="desktop-nav-row" style="position: absolute; bottom: 20px; right: 20px; z-index: 5; pointer-events: none;">
                                <button class="card-action-small" id="speakBtn" title="Speak word" style="pointer-events: auto;">
                                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                        <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                                        <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                                        <path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path>
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <div class="card-face card-back">
                            <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; position: absolute; top: 20px; left: 0; padding: 0 20px; pointer-events: none;">
                                <div style="display: flex; gap: 10px; align-items: center; pointer-events: auto;">
                                    <button class="nav-btn-inline" id="prevBtnBack">â†</button>
                                    <button class="nav-btn-inline desktop-answer-btn" id="incorrectBtnTop" title="Mark as incorrect" style="display: none; background: var(--error); color: white; border-color: var(--error);">âœ—</button>
                                </div>
                                <div style="display: flex; gap: 10px; align-items: center; pointer-events: auto;">
                                    <button class="nav-btn-inline desktop-answer-btn" id="correctBtnTop" title="Mark as correct" style="display: none; background: var(--success); color: white; border-color: var(--success);">âœ“</button>
                                    <button class="nav-btn-inline" id="nextBtnBack">â†’</button>
                                </div>
                            </div>
                            <div class="card-details" id="backContent"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Authentication Modal -->
    <div id="authModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header" style="border-bottom: none; padding-bottom: 10px;">
                <h3 style="width: 100%; text-align: center; color: white;">Welcome to Flashcards</h3>
            </div>
            <div class="auth-body">
                <p style="text-align: center; color: var(--text-secondary); margin-bottom: 25px;">
                    Choose how you'd like to use the app
                </p>

                <button class="auth-btn login-btn" id="loginModeBtn">
                    <div class="auth-btn-content">
                        <span class="auth-btn-title">Login with Name</span>
                        <span class="auth-btn-desc">Track progress across devices</span>
                    </div>
                </button>

                <button class="auth-btn guest-btn" id="guestModeBtn">
                    <div class="auth-btn-content">
                        <span class="auth-btn-title">Guest Mode</span>
                        <span class="auth-btn-desc">Practice locally, no data saved</span>
                    </div>
                </button>

                <div id="loginForm" class="login-form hidden">
                    <label for="userInitials" style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 14px;">
                        Enter your initials (2-4 letters)
                    </label>
                    <input
                        type="text"
                        id="userInitials"
                        class="initials-input"
                        placeholder="e.g., JD"
                        maxlength="4"
                        autocomplete="off"
                    />
                    <div class="login-form-actions">
                        <button class="auth-submit-btn" id="submitInitialsBtn">Continue</button>
                        <button class="auth-cancel-btn" id="cancelLoginBtn">Back</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Deck Complete Modal -->
    <div id="deckCompleteModal" class="modal hidden">
        <div class="modal-content" style="max-width: 350px;">
            <div class="modal-header" style="border-bottom: none; padding-bottom: 0;">
                <h3 style="width: 100%; text-align: center;">Deck Complete!</h3>
            </div>
            <div class="deck-complete-body">
                <div class="deck-complete-stats">
                    <div class="deck-stat correct-stat">
                        <span class="deck-stat-emoji">âœ“</span>
                        <span id="completeCorrect">0</span>
                    </div>
                    <div class="deck-stat incorrect-stat">
                        <span class="deck-stat-emoji">âœ—</span>
                        <span id="completeIncorrect">0</span>
                    </div>
                </div>
                <div id="completeAccuracy" style="text-align: center; font-size: 18px; color: var(--text-secondary); margin-bottom: 20px;"></div>
                <div id="completeMessage" style="text-align: center; color: var(--text-secondary); margin-bottom: 20px;"></div>
                <div class="deck-complete-actions">
                    <button class="deck-complete-btn restart-btn" id="restartAllBtn">
                        <span class="btn-icon">ðŸ”„</span>
                        <span>Restart All</span>
                    </button>
                    <button class="deck-complete-btn continue-btn" id="continueIncorrectBtn">
                        <span class="btn-icon">ðŸ“</span>
                        <span>Review Mistakes</span>
                    </button>
                </div>
                <button class="deck-complete-btn mark-complete-btn" id="markCompleteBtn">
                    <span class="btn-icon">âœ…</span>
                    <span>Mark Complete & Exit</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Stats Modal -->
    <div id="statsModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Your Progress</h3>
                <button class="modal-close" id="closeStatsModal">âœ•</button>
            </div>
            <div class="stats-body">
                <div class="stat-row">
                    <span>Cards Studied:</span>
                    <span id="cardsStudied">0</span>
                </div>
                <div class="stat-row">
                    <span>Total Cards:</span>
                    <span id="totalCardsStats">0</span>
                </div>
                <div class="stat-row">
                    <span>Progress:</span>
                    <span id="progressPercent">0%</span>
                </div>
                <div class="stat-row">
                    <span style="color: var(--accent-green);">âœ“ Correct:</span>
                    <span id="correctCount" style="color: var(--accent-green);">0</span>
                </div>
                <div class="stat-row">
                    <span style="color: var(--error);">âœ— Incorrect:</span>
                    <span id="incorrectCount" style="color: var(--error);">0</span>
                </div>
                <div class="stat-row">
                    <span>Accuracy:</span>
                    <span id="accuracyPercent">-</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Total Stats Modal (All-time stats for the current language) -->
    <div id="totalStatsModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Total Stats - <span id="totalStatsLanguage">Spanish</span></h3>
                <button class="modal-close" id="closeTotalStatsModal">âœ•</button>
            </div>
            <div class="stats-body">
                <div class="stat-row">
                    <span style="color: var(--accent-green);">Words Correct:</span>
                    <span id="totalWordsCorrect" style="color: var(--accent-green);">0</span>
                </div>
                <div class="stat-row">
                    <span>Words Seen:</span>
                    <span id="totalWordsSeen">0</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal with Tabs -->
    <div id="settingsModal" class="modal hidden">
        <div class="modal-content">
            <!-- Tab buttons as header -->
            <div class="settings-tabs-header">
                <div class="settings-tabs">
                    <button class="settings-tab active" data-tab="settings">Settings</button>
                    <button class="settings-tab" data-tab="stats">Stats</button>
                    <button class="settings-tab" data-tab="account">Account</button>
                </div>
                <button class="modal-close" id="closeSettingsModal">âœ•</button>
            </div>
            <!-- Settings tab content -->
            <div class="settings-tab-content active" id="settingsTabContent">
                <div class="stat-row" style="cursor: pointer;" id="autoSpeakToggle">
                    <span>Auto-speak words</span>
                    <span id="autoSpeakStatus" style="color: var(--accent-primary);">ON</span>
                </div>
                <div class="stat-row" style="cursor: pointer; display: none;" id="refreshSetToggle">
                    <span>Refresh this study set</span>
                    <span style="color: var(--warning);">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"></path>
                        </svg>
                    </span>
                </div>
            </div>
            <!-- Stats tab content -->
            <div class="settings-tab-content" id="statsTabContent">
                <div class="stat-row">
                    <span id="statsTabLanguage" style="color: var(--accent-primary); font-weight: 600;">Spanish</span>
                </div>
                <div class="stat-row">
                    <span>Words correct</span>
                    <span id="statsTabWordsCorrect" style="color: var(--accent-green);">0</span>
                </div>
                <div class="stat-row">
                    <span>Words seen</span>
                    <span id="statsTabWordsSeen">0</span>
                </div>
            </div>
            <!-- Account tab content -->
            <div class="settings-tab-content" id="accountTabContent">
                <div class="stat-row">
                    <span>Logged in as</span>
                    <span id="accountUserBadge" style="color: var(--accent-primary);">GUEST</span>
                </div>
                <div class="stat-row" style="cursor: pointer;" id="logoutBtn">
                    <span>Logout</span>
                    <span style="color: var(--error);">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
                            <polyline points="16 17 21 12 16 7"></polyline>
                            <line x1="21" y1="12" x2="9" y2="12"></line>
                        </svg>
                    </span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Register service worker for PWA functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('service-worker.js')
                    .then(registration => console.log('SW registered'))
                    .catch(err => console.log('SW registration failed'));
            });
        }

        let flashcards = [];
        let currentIndex = 0;
        let currentSentenceIndex = 0; // Track which example sentence is being shown
        let currentMeaningIndex = 0; // Track which meaning is selected
        let stats = {
            studied: new Set(),
            correct: 0,
            incorrect: 0,
            total: 0,
            cardStats: {} // Track individual card performance: cardIndex -> {correct: count, incorrect: count}
        };
        let currentMode = 'flashcards';
        let config = null;
        let selectedLanguage = 'spanish';
        let selectedLevel = null;
        let selectedRanges = [];
        let isFlipped = false;
        let groupSize = 25; // Default group size
        let useLemmaMode = true; // Whether to use 1 card per lemma mode
        let lemmaFieldAvailable = false; // Whether vocabulary has most_frequent_lemma_instance field
        let isAppInitialized = false; // Track if event listeners have been set up
        let cefrLevelsConfig = null; // CEFR levels configuration for lemma/standard modes
        let speechEnabled = true; // Text-to-speech toggle

        // Language codes for Web Speech API
        const speechLangCodes = {
            spanish: 'es-ES',
            swedish: 'sv-SE',
            italian: 'it-IT',
            dutch: 'nl-NL',
            polish: 'pl-PL',
            french: 'fr-FR',
            russian: 'ru-RU'
        };

        // Speak a word in the target language
        function speakWord(text, useEnglish = false) {
            if (!speechEnabled || !text || !window.speechSynthesis) return;

            // Cancel any ongoing speech
            window.speechSynthesis.cancel();

            const utterance = new SpeechSynthesisUtterance(text);
            const langCode = useEnglish ? 'en-GB' : (speechLangCodes[selectedLanguage] || 'es-ES');
            utterance.lang = langCode;
            utterance.rate = 0.9; // Slightly slower for learning

            // Try to find a better quality voice
            const voices = window.speechSynthesis.getVoices();
            if (voices.length > 0) {
                // Prefer Google or premium voices, then any matching voice
                const preferredVoice = voices.find(v =>
                    v.lang.startsWith(langCode.split('-')[0]) &&
                    (v.name.includes('Google') || v.name.includes('Premium') || v.name.includes('Enhanced') || v.name.includes('Samantha') || v.name.includes('Daniel'))
                ) || voices.find(v => v.lang.startsWith(langCode.split('-')[0]));

                if (preferredVoice) {
                    utterance.voice = preferredVoice;
                }
            }

            window.speechSynthesis.speak(utterance);
        }

        // Preload voices (they may not be available immediately)
        if (window.speechSynthesis) {
            window.speechSynthesis.getVoices();
            window.speechSynthesis.onvoiceschanged = () => {
                window.speechSynthesis.getVoices();
            };
        }

        // ========== AUTHENTICATION & GOOGLE SHEETS ==========

        // Configuration - Replace this with your deployed Google Apps Script URL
        const GOOGLE_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbwZI7L1gQGY5YUyfxcKJrT--EEmRNSc1pkBgNnPJMlaUie_ZDPiJcY_XPKbRDEHAYuF/exec';


        let currentUser = null; // { initials: string, isGuest: boolean }
        let progressData = {}; // wordRank -> { correct, wrong, lastSeen }

        // Check authentication on page load
        function checkAuthentication() {
            const savedUser = localStorage.getItem('flashcardUser');
            if (savedUser) {
                currentUser = JSON.parse(savedUser);
                showUserInfo();
                if (!currentUser.isGuest) {
                    loadUserProgressFromSheet();
                }
                hideAuthModal();
            } else {
                showAuthModal();
            }
        }

        // Show authentication modal
        function showAuthModal() {
            const authModal = document.getElementById('authModal');
            authModal.classList.remove('hidden');
            document.getElementById('setupPanel').style.display = 'none';
        }

        // Hide authentication modal
        function hideAuthModal() {
            const authModal = document.getElementById('authModal');
            authModal.classList.add('hidden');
            document.getElementById('setupPanel').style.display = 'block';
        }

        // Show user info badge
        function showUserInfo() {
            const userInfo = document.getElementById('userInfo');
            const userBadge = document.getElementById('userBadge');
            userBadge.textContent = currentUser.isGuest ? 'GUEST' : currentUser.initials;
            userInfo.classList.remove('hidden');
        }

        // Guest mode handler
        function enterGuestMode() {
            currentUser = { isGuest: true };
            localStorage.setItem('flashcardUser', JSON.stringify(currentUser));
            showUserInfo();
            hideAuthModal();
            updateIncorrectButtonVisibility();
        }

        // Show login form
        function showLoginForm() {
            document.getElementById('guestModeBtn').style.display = 'none';
            document.getElementById('loginModeBtn').style.display = 'none';
            document.getElementById('loginForm').classList.remove('hidden');
            document.getElementById('userInitials').focus();
        }

        // Hide login form
        function hideLoginForm() {
            document.getElementById('guestModeBtn').style.display = 'flex';
            document.getElementById('loginModeBtn').style.display = 'flex';
            document.getElementById('loginForm').classList.add('hidden');
            document.getElementById('userInitials').value = '';
        }

        // Submit initials and login
        async function submitLogin() {
            const initials = document.getElementById('userInitials').value.trim().toUpperCase();

            if (initials.length < 2 || initials.length > 4 || !/^[A-Z]+$/.test(initials)) {
                alert('Please enter 2-4 letters (A-Z only)');
                return;
            }

            currentUser = { initials: initials, isGuest: false };
            localStorage.setItem('flashcardUser', JSON.stringify(currentUser));
            showUserInfo();
            hideAuthModal();

            // Load user progress from Google Sheets
            await loadUserProgressFromSheet();
        }

        // Logout handler
        function logout() {
            if (confirm('Are you sure you want to logout? Unsaved progress will be lost.')) {
                localStorage.removeItem('flashcardUser');
                currentUser = null;
                progressData = {};
                document.getElementById('userInfo').classList.add('hidden');

                // Reset app state
                flashcards = [];
                currentIndex = 0;
                stats = {
                    studied: new Set(),
                    correct: 0,
                    incorrect: 0,
                    total: 0,
                    cardStats: {}
                };

                // Hide app content and show auth modal
                document.getElementById('appContent').classList.add('hidden');
                showAuthModal();
            }
        }

        // ========== GOOGLE SHEETS INTEGRATION ==========

        // Load user progress from Google Sheets
        async function loadUserProgressFromSheet() {
            if (!currentUser || currentUser.isGuest) return;

            try {
                const response = await fetch(GOOGLE_SCRIPT_URL, {
                    method: 'POST',
                    body: JSON.stringify({
                        action: 'load',
                        user: currentUser.initials
                    })
                });

                const result = await response.json();

                if (result.success && result.data && result.data.progress) {
                    // Convert array to object for easier lookup
                    progressData = {};
                    result.data.progress.forEach(item => {
                        progressData[item.wordRank] = {
                            word: item.word,
                            language: item.language,
                            correct: item.correct,
                            wrong: item.wrong,
                            lastCorrect: item.lastCorrect,
                            lastWrong: item.lastWrong,
                            lastSeen: item.lastSeen
                        };
                    });
                    console.log(`Loaded progress for ${result.data.progress.length} words`);
                    updateIncorrectButtonVisibility();
                    updateTotalStatsButtonVisibility();
                }
            } catch (error) {
                console.error('Failed to load progress from Google Sheets:', error);
                // Continue anyway - user can still practice
            }
        }

        // Save progress for a single word to Google Sheets
        async function saveWordProgress(card, isCorrect) {
            // Use originalRank for progress tracking (matches vocabulary file index)
            const wordRank = card.rank; // rank is now the unique identifier
            const word = card.targetWord;
            const language = selectedLanguage;
            const timestamp = new Date().toISOString();

            if (!currentUser || currentUser.isGuest) {
                // For guest mode, save to LocalStorage
                saveToLocalStorage(wordRank, isCorrect);
                return;
            }

            // Update local progress data
            if (!progressData[wordRank]) {
                progressData[wordRank] = {
                    word: word,
                    language: language,
                    correct: 0,
                    wrong: 0,
                    lastCorrect: null,
                    lastWrong: null,
                    lastSeen: null
                };
            }

            if (isCorrect) {
                progressData[wordRank].correct++;
                progressData[wordRank].lastCorrect = timestamp;
            } else {
                progressData[wordRank].wrong++;
                progressData[wordRank].lastWrong = timestamp;
            }
            progressData[wordRank].lastSeen = timestamp;
            progressData[wordRank].word = word;
            progressData[wordRank].language = language;

            // Save to Google Sheets
            try {
                const response = await fetch(GOOGLE_SCRIPT_URL, {
                    method: 'POST',
                    body: JSON.stringify({
                        action: 'save',
                        user: currentUser.initials,
                        word: word,
                        language: language,
                        wordRank: wordRank,
                        correct: progressData[wordRank].correct,
                        wrong: progressData[wordRank].wrong,
                        lastCorrect: progressData[wordRank].lastCorrect,
                        lastWrong: progressData[wordRank].lastWrong,
                        lastSeen: progressData[wordRank].lastSeen
                    })
                });

                const result = await response.json();
                if (!result.success) {
                    console.error('Failed to save progress:', result.message);
                }
            } catch (error) {
                console.error('Failed to save progress to Google Sheets:', error);
                // Fallback to LocalStorage
                saveToLocalStorage(wordRank, isCorrect);
            }
        }

        // LocalStorage fallback for guest mode
        function saveToLocalStorage(wordRank, isCorrect) {
            const key = 'flashcard_progress_guest';
            let guestProgress = JSON.parse(localStorage.getItem(key) || '{}');

            if (!guestProgress[wordRank]) {
                guestProgress[wordRank] = { correct: 0, wrong: 0 };
            }

            if (isCorrect) {
                guestProgress[wordRank].correct++;
            } else {
                guestProgress[wordRank].wrong++;
            }

            localStorage.setItem(key, JSON.stringify(guestProgress));
        }

        // Setup authentication modal event listeners
        function setupAuthEventListeners() {
            // Guest mode button
            document.getElementById('guestModeBtn').addEventListener('click', enterGuestMode);

            // Login mode button
            document.getElementById('loginModeBtn').addEventListener('click', showLoginForm);

            // Cancel login button
            document.getElementById('cancelLoginBtn').addEventListener('click', hideLoginForm);

            // Submit initials button
            document.getElementById('submitInitialsBtn').addEventListener('click', submitLogin);

            // Enter key in initials input
            document.getElementById('userInitials').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    submitLogin();
                }
            });

            // Enable/disable submit button based on input
            document.getElementById('userInitials').addEventListener('input', (e) => {
                const initials = e.target.value.trim();
                const submitBtn = document.getElementById('submitInitialsBtn');
                const isValid = initials.length >= 2 && initials.length <= 4 && /^[A-Za-z]+$/.test(initials);
                submitBtn.disabled = !isValid;
            });

            // Logout button (now in settings modal)
            document.getElementById('logoutBtn').addEventListener('click', function() {
                hideSettingsModal();
                logout();
            });

            // Gear button opens settings modal
            document.getElementById('gearBtn').addEventListener('click', function() {
                showSettingsModal();
            });

            // Settings modal tabs
            document.querySelectorAll('.settings-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    const tabName = this.dataset.tab;

                    // Update active tab button
                    document.querySelectorAll('.settings-tab').forEach(t => t.classList.remove('active'));
                    this.classList.add('active');

                    // Update active tab content
                    document.querySelectorAll('.settings-tab-content').forEach(c => c.classList.remove('active'));
                    document.getElementById(tabName + 'TabContent').classList.add('active');
                });
            });

            // Settings modal close button
            document.getElementById('closeSettingsModal').addEventListener('click', hideSettingsModal);

            // Click outside settings modal to close
            document.getElementById('settingsModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    hideSettingsModal();
                }
            });

            // Total stats modal close button
            document.getElementById('closeTotalStatsModal').addEventListener('click', hideTotalStatsModal);

            // Click outside total stats modal to close
            document.getElementById('totalStatsModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    hideTotalStatsModal();
                }
            });

            // Stats button in pill - opens settings modal on Stats tab
            document.getElementById('statsBtnPill').addEventListener('click', function(e) {
                e.stopPropagation();
                showSettingsModalWithTab('stats');
            });
        }

        // ========== END AUTHENTICATION & GOOGLE SHEETS ==========

        // Load configuration
        async function loadConfig() {
            try {
                const [configResponse, cefrResponse] = await Promise.all([
                    fetch('config.json'),
                    fetch('cefr_levels.json')
                ]);
                config = await configResponse.json();
                cefrLevelsConfig = await cefrResponse.json();
            } catch (error) {
                console.error('Failed to load config:', error);
                alert('Failed to load configuration. Please refresh the page.');
            }
        }

        // Get the CEFR levels for the language (always use standard, not lemma-specific ranges)
        function getCefrLevels(language) {
            if (cefrLevelsConfig && cefrLevelsConfig[language]) {
                // Always use standard levels - lemma mode just filters cards within the same ranges
                return cefrLevelsConfig[language].standard;
            }
            // Fallback to config.json levels
            return config.languages[language].cefrLevels;
        }

        // Setup tooltip handlers (needs to run early, before any set is picked)
        function setupTooltipHandlers() {
            // Step help tooltip handlers
            document.querySelectorAll('.step-help-btn').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const tooltipId = this.dataset.tooltip;
                    const tooltip = document.getElementById(tooltipId);

                    // Close all other tooltips first
                    document.querySelectorAll('.step-info-tooltip').forEach(t => {
                        if (t.id !== tooltipId) {
                            t.classList.remove('visible');
                        }
                    });

                    // Toggle this tooltip
                    tooltip.classList.toggle('visible');
                });
            });

            // Close tooltips when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.step-help-btn') && !e.target.closest('.step-info-tooltip')) {
                    document.querySelectorAll('.step-info-tooltip').forEach(t => {
                        t.classList.remove('visible');
                    });
                }
            });

            // Incorrect words set button handler
            document.getElementById('incorrectSetBtn').addEventListener('click', function(e) {
                e.stopPropagation();
                loadIncorrectWordsSet();
            });
        }

        // Update incorrect button visibility based on login status and available incorrect words
        function updateIncorrectButtonVisibility() {
            const btn = document.getElementById('incorrectSetBtn');
            if (!btn) return;

            // Only show for logged-in users who have incorrect words for the current language
            if (currentUser && !currentUser.isGuest && progressData) {
                const incorrectCount = Object.values(progressData).filter(
                    data => data.wrong > 0 && data.language === selectedLanguage
                ).length;

                if (incorrectCount > 0) {
                    btn.classList.add('visible');
                    btn.textContent = `Incorrect (${incorrectCount})`;
                } else {
                    btn.classList.remove('visible');
                }
            } else {
                btn.classList.remove('visible');
            }
        }

        // Initialize on page load
        loadConfig().then(() => {
            renderLanguageTabs();
            // Set first language with data as default (but don't auto-select it)
            const firstLang = Object.keys(config.languages).find(lang => config.languages[lang].hasData !== false) || Object.keys(config.languages)[0];
            selectedLanguage = firstLang;
            applyLanguageColorTheme();
            // Don't render level selector yet - wait for user to select a language
            // renderLevelSelector(firstLang);
            setupGroupSizeSelector();
            setupLemmaToggle();
            // updateLemmaToggleVisibility(); // Don't call yet - wait for language selection
            setupTooltipHandlers(); // Initialize tooltips early
            setupAuthEventListeners(); // Setup auth modal event listeners
            checkAuthentication(); // Check if user is logged in
        });

        function renderLanguageTabs() {
            const tabsContainer = document.getElementById('languageTabs');

            // Define custom language order (Polish before grayed-out French and Russian)
            const languageOrder = ['spanish', 'swedish', 'italian', 'dutch', 'polish', 'french', 'russian'];
            const languages = languageOrder.filter(lang => config.languages[lang]);

            // Map language keys to 2-letter codes
            const langCodeMap = {
                'dutch': 'NL',
                'polish': 'PL',
                'spanish': 'ES',
                'italian': 'IT',
                'french': 'FR',
                'russian': 'RU',
                'swedish': 'SE'
            };

            // Generate language tabs dynamically - no active state initially
            const tabsHTML = languages.map((langKey, index) => {
                const langCode = langCodeMap[langKey] || langKey.substring(0, 2).toUpperCase();
                const langConfig = config.languages[langKey];
                const hasData = langConfig.hasData !== false;
                // Don't pre-select any language - user must click to select
                const activeClass = '';
                const disabledClass = !hasData ? 'disabled' : '';
                const disabledAttr = !hasData ? 'disabled' : '';
                const title = !hasData ? `${langConfig.name} - Data coming soon` : '';
                return `<button class="lang-tab ${activeClass} ${disabledClass}" data-lang="${langKey}" ${disabledAttr} title="${title}">${langCode}</button>`;
            }).join('');

            tabsContainer.innerHTML = tabsHTML;

            // Setup event listeners for tabs
            setupLanguageTabs();
        }

        function setupLanguageTabs() {
            document.querySelectorAll('.lang-tab').forEach(tab => {
                tab.addEventListener('click', async function() {
                    // Prevent clicking on disabled tabs
                    if (this.disabled || this.classList.contains('disabled')) {
                        return;
                    }
                    document.querySelectorAll('.lang-tab').forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    selectedLanguage = this.dataset.lang;
                    selectedLevel = null;
                    applyLanguageColorTheme();

                    // Update and show the inline selected language display with animation
                    const langConfig = config.languages[selectedLanguage];
                    const selectedLangInline = document.getElementById('selectedLanguageInline');
                    document.getElementById('selectedLanguageName').textContent = langConfig ? langConfig.name : selectedLanguage;

                    // Trigger animation by adding visible class
                    selectedLangInline.classList.add('visible');

                    // Hide all subsequent steps while loading
                    document.getElementById('step2').style.display = 'none';
                    document.getElementById('lemmaToggleContainer').style.display = 'none';
                    document.getElementById('step3').style.display = 'none';
                    document.getElementById('step4').style.display = 'none';

                    // Show loading indicator
                    const loadingIndicator = document.getElementById('dataLoadingIndicator');
                    loadingIndicator.classList.add('visible');

                    // Refresh progress data from Google Sheets
                    if (currentUser && !currentUser.isGuest) {
                        await loadUserProgressFromSheet();
                    }

                    // Hide loading indicator and show step 2
                    loadingIndicator.classList.remove('visible');
                    document.getElementById('step2').style.display = 'block';

                    renderLevelSelector(selectedLanguage);
                    updateLemmaToggleVisibility();
                    updateIncorrectButtonVisibility();
                    updateTotalStatsButtonVisibility();
                });
            });
        }

        function renderLevelSelector(language) {
            const container = document.getElementById('levelSelector');
            const cefrLevels = getCefrLevels(language);

            const levelsHTML = cefrLevels.map(level => `
                <button class="level-btn" data-level="${level.level}" title="${level.description}">
                    ${level.level}
                </button>
            `).join('');

            container.innerHTML = levelsHTML;

            // Add click handlers
            document.querySelectorAll('.level-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.level-btn').forEach(b => b.classList.remove('selected'));
                    this.classList.add('selected');
                    selectedLevel = this.dataset.level;
                    // Show steps 3 (lemma), 4 (cards per set), and 5 (range)
                    document.getElementById('lemmaToggleContainer').style.display = 'block';
                    document.getElementById('step3').style.display = 'block';
                    renderRangeSelector().catch(err => console.error('Error rendering ranges:', err));
                });
            });
        }

        function setupGroupSizeSelector() {
            document.querySelectorAll('.group-size-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.group-size-btn').forEach(b => b.classList.remove('selected'));
                    this.classList.add('selected');
                    groupSize = parseInt(this.dataset.size);
                    // Re-render range selector if a level is selected
                    if (selectedLevel) {
                        renderRangeSelector().catch(err => console.error('Error rendering ranges:', err));
                    }
                });
            });
        }

        function setupLemmaToggle() {
            document.querySelectorAll('.lemma-toggle-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    // Don't allow selecting "1" mode if lemma field not available
                    if (this.dataset.lemma === 'on' && !lemmaFieldAvailable) {
                        return;
                    }
                    document.querySelectorAll('.lemma-toggle-btn').forEach(b => b.classList.remove('selected'));
                    this.classList.add('selected');
                    useLemmaMode = this.dataset.lemma === 'on';
                    // Re-render level selector with new word counts, and re-render range selector if a level is selected
                    renderLevelSelector(selectedLanguage);
                    // Re-select the current level if one was selected
                    if (selectedLevel) {
                        const levelBtn = document.querySelector(`.level-btn[data-level="${selectedLevel}"]`);
                        if (levelBtn) {
                            levelBtn.classList.add('selected');
                        }
                        renderRangeSelector().catch(err => console.error('Error rendering ranges:', err));
                    }
                });
            });
        }

        async function updateLemmaToggleVisibility() {
            const langConfig = config.languages[selectedLanguage];
            const lemmaContainer = document.getElementById('lemmaToggleContainer');
            const lemmaSelector = document.getElementById('lemmaToggleSelector');
            const rangeStepNumber = document.getElementById('rangeStepNumber');

            // Check if vocabulary has most_frequent_lemma_instance field
            lemmaFieldAvailable = false;
            if (langConfig && langConfig.dataPath) {
                try {
                    const response = await fetch(langConfig.dataPath);
                    if (response.ok) {
                        const vocabData = await response.json();
                        // Check if at least one entry has the most_frequent_lemma_instance field
                        lemmaFieldAvailable = vocabData.some(item =>
                            item.hasOwnProperty('most_frequent_lemma_instance')
                        );
                    }
                } catch (error) {
                    console.error('Error checking lemma field availability:', error);
                }
            }

            // Always show the container (step 3), but disable the "1" option if field not available
            lemmaContainer.style.display = 'block';
            rangeStepNumber.textContent = '5';

            if (lemmaFieldAvailable) {
                // Enable both options
                lemmaSelector.classList.remove('lemma-toggle-unavailable');
            } else {
                // Disable the "1" option, force "1+" mode
                lemmaSelector.classList.add('lemma-toggle-unavailable');
                useLemmaMode = false;
                document.querySelectorAll('.lemma-toggle-btn').forEach(b => b.classList.remove('selected'));
                document.querySelector('.lemma-toggle-btn[data-lemma="off"]').classList.add('selected');
            }
        }

        function applyLanguageColorTheme() {
            const langConfig = config.languages[selectedLanguage];
            if (langConfig && langConfig.colorTheme) {
                const root = document.documentElement;
                root.style.setProperty('--accent-primary', langConfig.colorTheme.primary);
                root.style.setProperty('--accent-secondary', langConfig.colorTheme.secondary);

                // Convert hex to RGB for opacity usage
                const hexToRgb = (hex) => {
                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : '0, 0, 0';
                };

                root.style.setProperty('--accent-primary-rgb', hexToRgb(langConfig.colorTheme.primary));
                root.style.setProperty('--accent-secondary-rgb', hexToRgb(langConfig.colorTheme.secondary));
            }
        }

        async function renderRangeSelector() {
            const langConfig = config.languages[selectedLanguage];
            const cefrLevels = getCefrLevels(selectedLanguage);
            const level = cefrLevels.find(l => l.level === selectedLevel);
            const container = document.getElementById('rangeSelector');

            if (!level) return;

            // Parse the wordCount range for this level (e.g., "1-800" -> 1, 800)
            const [minWord, maxWord] = level.wordCount.split('-').map(Number);

            // Always use the regular data path
            const dataPath = langConfig.dataPath;

            // Load the vocabulary data to check which ranks exist
            let vocabularyData = [];
            try {
                if (dataPath) {
                    const response = await fetch(dataPath);
                    if (response.ok) {
                        vocabularyData = await response.json();
                    }
                }
            } catch (error) {
                console.error('Failed to load vocabulary data:', error);
            }

            // Assign original ranks (unique identifiers) to vocabulary items
            vocabularyData.forEach((item, index) => {
                item.rank = index + 1;
            });

            // Filter to non-blank entries and exclude duplicates
            let filteredVocab = vocabularyData.filter(item =>
                item.word && item.word.trim() !== '' && !item.duplicate && item.meanings && item.meanings.length > 0
            );

            // Filter to items within the level's range (using original ranks)
            filteredVocab = filteredVocab.filter(item =>
                item.rank >= minWord && item.rank < maxWord
            );

            // For lemma mode, further filter to only lemma instances
            let lemmaFilteredVocab = filteredVocab;
            if (useLemmaMode && lemmaFieldAvailable) {
                lemmaFilteredVocab = filteredVocab.filter(item => item.most_frequent_lemma_instance === true);
            }

            // Create a Set of all available ranks for fast lookup
            const availableRanks = new Set(lemmaFilteredVocab.map(item => item.rank));

            // Generate ALL possible range buttons based on groupSize across the full span
            const ranges = [];
            for (let i = minWord; i < maxWord; i += groupSize) {
                const rangeEnd = Math.min(i + groupSize, maxWord);

                // Check if ANY rank in this range has data (after lemma filtering)
                let hasData = false;
                let ranksInRange = [];
                for (let rank = i; rank < rangeEnd; rank++) {
                    if (availableRanks.has(rank)) {
                        hasData = true;
                        ranksInRange.push(rank);
                    }
                }

                // Check mastery and attempted status
                let isMastered = false;
                let isAttempted = false;
                if (hasData && currentUser && !currentUser.isGuest && progressData && ranksInRange.length > 0) {
                    const wordsInRange = lemmaFilteredVocab.filter(item => item.rank >= i && item.rank < rangeEnd);
                    if (wordsInRange.length > 0) {
                        // Check if ALL words in this range have been marked correct at least once
                        isMastered = wordsInRange.every(item => {
                            const progress = progressData[item.rank];
                            return progress && progress.correct > 0 && progress.language === selectedLanguage;
                        });

                        // Check if ANY word in this range has been attempted (correct OR wrong > 0)
                        if (!isMastered) {
                            isAttempted = wordsInRange.some(item => {
                                const progress = progressData[item.rank];
                                return progress && progress.language === selectedLanguage &&
                                       ((progress.correct && progress.correct > 0) || (progress.wrong && progress.wrong > 0));
                            });
                        }
                    }
                }

                ranges.push({
                    range: `${i}-${rangeEnd}`,
                    available: hasData,
                    mastered: isMastered,
                    attempted: isAttempted
                });
            }

            // Generate HTML with disabled state for unavailable ranges, mastered state for completed ranges, and attempted state
            const rangesHTML = ranges.map(r => {
                const disabledAttr = !r.available ? 'disabled' : '';
                const disabledClass = !r.available ? 'disabled' : '';
                const masteredClass = r.mastered ? 'mastered' : '';
                const attemptedClass = r.attempted ? 'attempted' : '';
                let title = 'Load ' + r.range;
                if (!r.available) {
                    title = 'Greyed out because no vocabulary data exists for this range yet';
                } else if (r.mastered) {
                    title = 'All words in this set answered correctly at least once';
                } else if (r.attempted) {
                    title = 'Some words in this set have been practiced';
                }
                return `
                    <button class="range-btn-new ${disabledClass} ${masteredClass} ${attemptedClass}"
                            data-range="${r.range}"
                            ${disabledAttr}
                            title="${title}">
                        ${r.range}
                    </button>
                `;
            }).join('');

            // Add "Next Level" button at the end
            const currentLevelIndex = cefrLevels.findIndex(l => l.level === selectedLevel);
            const nextLevel = currentLevelIndex < cefrLevels.length - 1 ? cefrLevels[currentLevelIndex + 1] : null;

            let nextLevelHTML = '';
            if (nextLevel) {
                nextLevelHTML = `
                    <button class="range-btn-new next-level-btn"
                            data-next-level="${nextLevel.level}"
                            title="Go to ${nextLevel.level}">
                        Next Level
                    </button>
                `;
            } else {
                // At the last level, show placeholder box
                nextLevelHTML = `
                    <button class="range-btn-new disabled"
                            disabled
                            title="Completed all levels">
                        ${selectedLevel}
                    </button>
                `;
            }

            container.innerHTML = rangesHTML + nextLevelHTML;
            document.getElementById('step4').style.display = 'block';

            // Add click handlers to ALL buttons
            document.querySelectorAll('.range-btn-new').forEach(btn => {
                btn.addEventListener('click', async function(e) {
                    // Handle "Next Level" button
                    if (this.classList.contains('next-level-btn')) {
                        const nextLevelValue = this.dataset.nextLevel;
                        if (nextLevelValue) {
                            selectedLevel = nextLevelValue;
                            // Update level selector UI
                            document.querySelectorAll('.level-btn').forEach(b => b.classList.remove('selected'));
                            const nextLevelBtn = document.querySelector(`.level-btn[data-level="${nextLevelValue}"]`);
                            if (nextLevelBtn) {
                                nextLevelBtn.classList.add('selected');
                            }
                            // Re-render range selector for the new level
                            await renderRangeSelector();
                        }
                        return;
                    }

                    // Prevent disabled buttons from being clicked
                    if (this.disabled || this.classList.contains('disabled')) {
                        e.preventDefault();
                        e.stopPropagation();
                        // Show tooltip message for unavailable datasets
                        const loadingMsg = document.getElementById('loadingMessage');
                        loadingMsg.style.display = 'block';
                        loadingMsg.style.color = 'var(--warning)';
                        loadingMsg.textContent = 'Data not available, pick another set';
                        setTimeout(() => {
                            loadingMsg.style.display = 'none';
                            loadingMsg.style.color = 'var(--accent-green)';
                        }, 2000);
                        return;
                    }

                    const selectedRange = this.dataset.range;

                    document.getElementById('loadingMessage').style.display = 'block';
                    document.getElementById('loadingMessage').textContent = `Loading ${selectedRange}...`;

                    await loadVocabularyData(selectedRange);
                });
            });
        }

        async function loadVocabularyData(rangeString) {
            // Completely clear all previous data and state
            flashcards = [];
            currentIndex = 0;
            currentSentenceIndex = 0;
            currentMeaningIndex = 0;
            isFlipped = false;

            // Reset card flip state
            const flashcardEl = document.getElementById('flashcard');
            if (flashcardEl) {
                flashcardEl.classList.remove('flipped');
            }

            const langConfig = config.languages[selectedLanguage];
            const [rangeStart, rangeEnd] = rangeString.split('-').map(Number);

            // Always use the regular data path
            const dataPath = langConfig.dataPath;

            try {
                // Load the vocabulary JSON
                const response = await fetch(dataPath);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const vocabularyData = await response.json();

                // Store original index/rank from vocabulary file - this is the unique identifier
                vocabularyData.forEach((item, index) => {
                    item.rank = index + 1; // Use original position as the rank (unique identifier)
                });

                // Filter to non-blank entries and exclude duplicates
                let filteredData = vocabularyData.filter(item =>
                    item.word &&
                    item.word.trim() !== '' &&
                    !item.duplicate &&
                    item.meanings &&
                    item.meanings.length > 0
                );

                // Filter by the requested range (using original ranks)
                filteredData = filteredData.filter(item =>
                    item.rank >= rangeStart && item.rank < rangeEnd
                );

                // If in lemma mode, filter to only entries where most_frequent_lemma_instance is true
                // This happens AFTER range filtering, so lemma mode just shows fewer cards within the same range
                if (useLemmaMode && lemmaFieldAvailable) {
                    filteredData = filteredData.filter(item => item.most_frequent_lemma_instance === true);
                }

                // Filter out words the user has already got correct (for logged-in users)
                if (currentUser && !currentUser.isGuest && progressData) {
                    const beforeCount = filteredData.length;
                    filteredData = filteredData.filter(item => {
                        const progress = progressData[item.rank];
                        // Keep the word if no progress exists, or if correct is 0 or undefined
                        return !progress || !progress.correct || progress.correct === 0 || progress.language !== selectedLanguage;
                    });
                    const removedCount = beforeCount - filteredData.length;
                    if (removedCount > 0) {
                        console.log(`Filtered out ${removedCount} previously mastered words`);
                    }
                }

                // Convert to flashcards format
                const exampleTargetField = langConfig.exampleTargetField || 'example_spanish';
                const exampleEnglishField = langConfig.exampleEnglishField || 'example_english';

                for (const item of filteredData) {
                    const meanings = item.meanings.map(m => ({
                        pos: m.pos,
                        meaning: m.translation,
                        percentage: parseFloat(m.frequency),
                        targetSentence: m[exampleTargetField],
                        englishSentence: m[exampleEnglishField]
                    }));

                    // Normalize percentages if they're missing or sum to 0
                    const totalPercentage = meanings.reduce((sum, m) => sum + (m.percentage || 0), 0);
                    if (totalPercentage === 0 || isNaN(totalPercentage)) {
                        // Default to equal distribution
                        const equalPercentage = 1.0 / meanings.length;
                        meanings.forEach(m => {
                            m.percentage = equalPercentage;
                        });
                    } else if (totalPercentage !== 1.0) {
                        // Normalize to sum to 1.0
                        meanings.forEach(m => {
                            m.percentage = (m.percentage || 0) / totalPercentage;
                        });
                    }

                    const card = {
                        targetWord: item.word,
                        lemma: item.lemma || '',
                        rank: item.rank, // This is now the unique identifier (original vocabulary file position)
                        meanings: meanings,
                        translation: item.meanings[0].translation,
                        targetSentence: item.meanings[0][exampleTargetField],
                        englishSentence: item.meanings[0][exampleEnglishField],
                        links: generateLinks(item.word, item.lemma || item.word, langConfig.referenceLinks),
                        isMultiMeaning: true
                    };
                    flashcards.push(card);
                }

                if (filteredData.length === 0) {
                    // Check if this is because all words are mastered
                    if (currentUser && !currentUser.isGuest && progressData) {
                        alert('You\'ve already mastered all words in this set! Choose another set or use the "Refresh Set" option in settings to reset your progress.');
                    } else {
                        alert('No flashcards found in this range. Please try another set.');
                    }
                    document.getElementById('loadingMessage').style.display = 'none';
                    return;
                }

                // Successfully loaded data - show cards and hide setup
                document.getElementById('setupPanel').classList.add('hidden');
                document.getElementById('appContent').classList.remove('hidden');
                document.getElementById('loadingMessage').style.display = 'none';

                // Show mobile floating buttons
                showFloatingBtns(true);

                // Initialize card display
                initializeApp();
            } catch (error) {
                console.error(`Failed to load vocabulary data:`, error);
                document.getElementById('loadingMessage').style.display = 'none';
                alert(`Error loading ${rangeString}. Please try another set.`);
            }
        }

        // Load study set of all-time incorrect words for the selected language
        async function loadIncorrectWordsSet() {
            if (!currentUser || currentUser.isGuest) {
                alert('Please log in to access your incorrect words history.');
                return;
            }

            // Get incorrect words for the currently selected language
            const incorrectWords = Object.entries(progressData)
                .filter(([wordRank, data]) =>
                    data.wrong > 0 &&
                    data.language === selectedLanguage
                )
                .map(([wordRank, data]) => ({
                    wordRank: parseInt(wordRank),
                    ...data
                }))
                // Sort by least recently correct (null lastCorrect = never correct, comes first)
                // Then by least recently wrong as secondary sort
                .sort((a, b) => {
                    // Never correct comes first
                    if (!a.lastCorrect && b.lastCorrect) return -1;
                    if (a.lastCorrect && !b.lastCorrect) return 1;
                    if (!a.lastCorrect && !b.lastCorrect) {
                        // Both never correct - sort by oldest wrong first
                        const aWrong = a.lastWrong ? new Date(a.lastWrong).getTime() : 0;
                        const bWrong = b.lastWrong ? new Date(b.lastWrong).getTime() : 0;
                        return aWrong - bWrong;
                    }
                    // Both have been correct - sort by oldest correct first
                    return new Date(a.lastCorrect).getTime() - new Date(b.lastCorrect).getTime();
                });

            if (incorrectWords.length === 0) {
                alert(`No incorrect words found for ${selectedLanguage}. Start practicing to build your incorrect words list!`);
                return;
            }

            document.getElementById('loadingMessage').style.display = 'block';
            document.getElementById('loadingMessage').textContent = `Loading ${incorrectWords.length} incorrect words...`;

            // Clear previous state
            flashcards = [];
            currentIndex = 0;
            currentSentenceIndex = 0;
            currentMeaningIndex = 0;
            isFlipped = false;

            const flashcardEl = document.getElementById('flashcard');
            if (flashcardEl) {
                flashcardEl.classList.remove('flipped');
            }

            const langConfig = config.languages[selectedLanguage];
            const dataPath = langConfig.dataPath;

            try {
                // Load the full vocabulary JSON to get card details
                const response = await fetch(dataPath);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const vocabularyData = await response.json();

                // Create a lookup map by original rank (before any filtering)
                // We need to match by word since progressData stores the original rank
                const wordToVocab = {};
                vocabularyData.forEach((item, index) => {
                    if (item.word && item.word.trim() !== '' && item.meanings && item.meanings.length > 0) {
                        // Store by original rank (index + 1)
                        wordToVocab[index + 1] = item;
                    }
                });

                const exampleTargetField = langConfig.exampleTargetField || 'example_spanish';
                const exampleEnglishField = langConfig.exampleEnglishField || 'example_english';

                // Build flashcards from incorrect words
                for (const incorrectWord of incorrectWords) {
                    const item = wordToVocab[incorrectWord.wordRank];
                    if (!item) continue; // Skip if word not found in vocabulary

                    const meanings = item.meanings.map(m => ({
                        pos: m.pos,
                        meaning: m.translation,
                        percentage: parseFloat(m.frequency),
                        targetSentence: m[exampleTargetField],
                        englishSentence: m[exampleEnglishField]
                    }));

                    // Normalize percentages
                    const totalPercentage = meanings.reduce((sum, m) => sum + (m.percentage || 0), 0);
                    if (totalPercentage === 0 || isNaN(totalPercentage)) {
                        const equalPercentage = 1.0 / meanings.length;
                        meanings.forEach(m => { m.percentage = equalPercentage; });
                    } else if (totalPercentage !== 1.0) {
                        meanings.forEach(m => { m.percentage = (m.percentage || 0) / totalPercentage; });
                    }

                    const card = {
                        targetWord: item.word,
                        lemma: item.lemma || '',
                        rank: incorrectWord.wordRank,
                        meanings: meanings,
                        translation: item.meanings[0].translation,
                        targetSentence: item.meanings[0][exampleTargetField],
                        englishSentence: item.meanings[0][exampleEnglishField],
                        links: generateLinks(item.word, item.lemma || item.word, langConfig.referenceLinks),
                        isMultiMeaning: true
                    };
                    flashcards.push(card);
                }

                if (flashcards.length === 0) {
                    alert('Could not load incorrect words. Please try again.');
                    document.getElementById('loadingMessage').style.display = 'none';
                    return;
                }

                // Successfully loaded - show cards and hide setup
                document.getElementById('setupPanel').classList.add('hidden');
                document.getElementById('appContent').classList.remove('hidden');
                document.getElementById('loadingMessage').style.display = 'none';

                // Show mobile floating buttons
                showFloatingBtns(true);

                // Initialize card display
                initializeApp();
            } catch (error) {
                console.error('Failed to load incorrect words set:', error);
                document.getElementById('loadingMessage').style.display = 'none';
                alert('Error loading incorrect words. Please try again.');
            }
        }

        async function loadCSVFiles(ranges) {
            // Completely clear all previous data and state
            flashcards = [];
            currentIndex = 0;
            currentSentenceIndex = 0;
            currentMeaningIndex = 0;
            isFlipped = false;

            // Reset card flip state
            const flashcardEl = document.getElementById('flashcard');
            if (flashcardEl) {
                flashcardEl.classList.remove('flipped');
            }

            const langConfig = config.languages[selectedLanguage];

            for (const range of ranges) {
                try {
                    const response = await fetch(range.path);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    const fileText = await response.text();

                    // Extract starting and ending rank from range (e.g., "0-50" -> 0, 50)
                    const [rangeStart, rangeEnd] = range.range.split('-').map(Number);
                    const startRank = rangeStart;

                    // Check if this set uses the new multi-meaning format
                    if (range.format === 'multiMeaning' || fileText.includes('|')) {
                        parseMultiMeaning(fileText, langConfig, rangeStart, rangeEnd);
                    } else if (langConfig.fileFormat === 'quizlet') {
                        parseQuizlet(fileText, langConfig, startRank, rangeStart, rangeEnd);
                    } else {
                        parseCSV(fileText, langConfig, startRank, rangeStart, rangeEnd);
                    }
                } catch (error) {
                    console.error(`Failed to load ${range.path}:`, error);
                    document.getElementById('loadingMessage').style.display = 'none';
                    alert(`Error loading ${range.range}. Please try another set.`);
                    return;
                }
            }

            if (flashcards.length === 0) {
                alert('No flashcards loaded. Please check your selection.');
                document.getElementById('loadingMessage').style.display = 'none';
                return;
            }

            // Successfully loaded data - show cards and hide setup
            document.getElementById('setupPanel').classList.add('hidden');
            document.getElementById('appContent').classList.remove('hidden');
            document.getElementById('loadingMessage').style.display = 'none';

            // Initialize card display
            updateCard();
        }

        function parseMultiMeaning(text, langConfig, rangeStart, rangeEnd) {
            const lines = text.split('\n');
            const wordGroups = {}; // Group meanings by rank

            for (const line of lines) {
                const trimmed = line.trim();
                if (!trimmed) continue;

                const parts = trimmed.split('|');
                if (parts.length < 8) continue;

                const rank = parseInt(parts[0]);
                const word = parts[1];
                const lemma = parts[2];
                const pos = parts[3];
                const meaning = parts[4];
                const percentage = parseFloat(parts[5]);
                const targetSentence = parts[6];
                const englishSentence = parts[7];

                if (!wordGroups[rank]) {
                    wordGroups[rank] = {
                        rank: rank,
                        word: word,
                        lemma: lemma,
                        meanings: []
                    };
                }

                wordGroups[rank].meanings.push({
                    pos: pos,
                    meaning: meaning,
                    percentage: percentage,
                    targetSentence: targetSentence,
                    englishSentence: englishSentence
                });
            }

            // Convert to flashcards array, filtering by range
            const ranks = Object.keys(wordGroups).map(Number).sort((a, b) => a - b);

            for (const rank of ranks) {
                if (rank >= rangeStart && rank < rangeEnd) {
                    const group = wordGroups[rank];

                    // Sort meanings by percentage (highest first)
                    group.meanings.sort((a, b) => b.percentage - a.percentage);

                    // Normalize percentages if they're missing or sum to 0
                    const totalPercentage = group.meanings.reduce((sum, m) => sum + (m.percentage || 0), 0);
                    if (totalPercentage === 0 || isNaN(totalPercentage)) {
                        // Default to equal distribution
                        const equalPercentage = 1.0 / group.meanings.length;
                        group.meanings.forEach(m => {
                            m.percentage = equalPercentage;
                        });
                    } else if (totalPercentage !== 1.0) {
                        // Normalize to sum to 1.0
                        group.meanings.forEach(m => {
                            m.percentage = (m.percentage || 0) / totalPercentage;
                        });
                    }

                    const card = {
                        targetWord: group.word,
                        lemma: group.lemma,
                        rank: group.rank,
                        meanings: group.meanings,
                        // For compatibility, set primary translation to most common meaning
                        translation: group.meanings[0].meaning,
                        targetSentence: group.meanings[0].targetSentence,
                        englishSentence: group.meanings[0].englishSentence,
                        links: generateLinks(group.word, group.lemma || group.word, langConfig.referenceLinks),
                        isMultiMeaning: true
                    };

                    flashcards.push(card);
                }
            }

            document.getElementById('loadingMessage').textContent = `âœ“ Loaded ${flashcards.length} cards!`;
            setTimeout(() => {
                document.getElementById('setupPanel').style.display = 'none';
                document.getElementById('appContent').classList.remove('hidden');
                initializeApp();
            }, 500);
        }

        function parseQuizlet(text, langConfig, startRank = 0, rangeStart = 0, rangeEnd = Infinity) {
            const lines = text.split('\n');
            let i = 0;
            let cardCount = 0;
            let totalCardsParsed = 0; // Track position in file

            while (i < lines.length) {
                const line = lines[i].trim();

                // Skip empty lines
                if (!line) {
                    i++;
                    continue;
                }

                // First line: word and translation
                // Format: "word\ttranslation" or "*inflected* (base)\ttranslation"
                const parts = line.split('\t');
                if (parts.length < 2) {
                    i++;
                    continue;
                }

                let targetWord = parts[0].trim();
                let translation = parts[1].trim();

                // Extract base form if present (e.g., "*mala* (malo)" -> base: "malo", inflected: "mala")
                let baseForm = targetWord;
                let inflectedForm = null;

                // Check for inflected form pattern: *inflected* (base)
                const inflectedMatch = targetWord.match(/\*(.+?)\*\s*\((.+?)\)/);
                if (inflectedMatch) {
                    inflectedForm = inflectedMatch[1];
                    baseForm = inflectedMatch[2];
                    targetWord = inflectedForm;
                }

                // Remove asterisks from translation
                translation = translation.replace(/\*/g, '');

                // Next line should be the example sentence in target language
                i++;
                const targetSentence = (i < lines.length) ? lines[i].trim() : '';

                // Next line should be the English translation of the sentence
                i++;
                const englishSentence = (i < lines.length) ? lines[i].trim() : '';

                // Create the flashcard
                if (targetWord && translation) {
                    const currentRank = startRank + totalCardsParsed;

                    // Only include cards within the specified range
                    if (currentRank >= rangeStart && currentRank < rangeEnd) {
                        // Build sentences array - always include primary sentence and a placeholder for demo
                        const sentences = [];
                        if (targetSentence || englishSentence) {
                            sentences.push({ target: targetSentence, english: englishSentence });
                        }
                        // Add a placeholder second sentence to demonstrate swipe functionality
                        sentences.push({ target: '', english: '(Swipe up/down for more examples - coming soon!)' });

                        const card = {
                            targetWord: targetWord,
                            translation: translation,
                            baseForm: baseForm,
                            inflectedForm: inflectedForm,
                            targetSentence: targetSentence,
                            englishSentence: englishSentence,
                            sentences: sentences,
                            rank: currentRank + 1, // Calculate frequency rank
                            links: generateLinks(baseForm, baseForm, langConfig.referenceLinks)
                        };

                        flashcards.push(card);
                        cardCount++;
                    }
                    totalCardsParsed++;
                }

                // Move past empty lines between entries
                i++;
                while (i < lines.length && !lines[i].trim()) {
                    i++;
                }
            }
        }

        function parseCSV(csv, langConfig) {
            const lines = csv.split('\n');
            const headers = lines[0].split(',').map(h => h.trim());

            // Find column indices
            const wordIndex = headers.indexOf(langConfig.wordColumn);
            const sentenceIndex = headers.indexOf(langConfig.sentenceColumn);

            // Spanish-specific columns
            const showIndex = langConfig.showColumn ? headers.indexOf(langConfig.showColumn) : -1;
            const lemmaIndex = langConfig.lemmaColumn ? headers.indexOf(langConfig.lemmaColumn) : -1;

            // Dutch-specific columns
            const posIndex = langConfig.posColumn ? headers.indexOf(langConfig.posColumn) : -1;

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                // Handle quoted fields with commas
                const values = parseCSVLine(line);

                if (values.length > wordIndex) {
                    const word = cleanValue(values[wordIndex]);
                    const sentence = sentenceIndex >= 0 ? cleanValue(values[sentenceIndex]) : '';

                    if (!word) continue;

                    let card = {
                        word: word,
                        sentence: sentence
                    };

                    // Handle Spanish format
                    if (langConfig.csvFormat === 'spanish') {
                        card.show = showIndex >= 0 ? cleanValue(values[showIndex]) : word;
                        card.lemma = lemmaIndex >= 0 ? cleanValue(values[lemmaIndex]) : word;
                        card.links = generateLinks(word, card.lemma, langConfig.referenceLinks);
                    }
                    // Handle Dutch format
                    else if (langConfig.csvFormat === 'dutch') {
                        card.pos = posIndex >= 0 ? cleanValue(values[posIndex]) : '';
                        card.lemma = word;
                        card.links = generateLinks(word, word, langConfig.referenceLinks);
                    }

                    flashcards.push(card);
                }
            }
        }

        function parseCSVLine(line) {
            const values = [];
            let current = '';
            let inQuotes = false;

            for (let char of line) {
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            values.push(current);
            return values;
        }

        function cleanValue(value) {
            return value ? value.replace(/^"|"$/g, '').trim() : '';
        }

        function generateLinks(word, lemma, linkTemplates) {
            const cleanWord = encodeURIComponent(lemma || word);
            const links = {};

            for (const [key, template] of Object.entries(linkTemplates)) {
                links[key] = template.replace('{word}', cleanWord);
            }

            return links;
        }

        function initializeApp() {
            updateCard();
            updateStats();

            // Ensure modal is hidden on initialization
            document.getElementById('statsModal').classList.add('hidden');

            // Only set up event listeners once
            if (isAppInitialized) {
                return;
            }
            isAppInitialized = true;

            // Event listeners
            // Flip button on front
            document.getElementById('flipBtn').addEventListener('click', function(e) {
                e.stopPropagation();
                flipCard();
            });

            // Flip on back side
            document.getElementById('flashcard').addEventListener('click', function(e) {
                // Don't flip if clicking on buttons, links, or elements with onclick handlers
                if (e.target.closest('.nav-btn-inline') ||
                    e.target.closest('.link-btn') ||
                    e.target.closest('.card-action-small') ||
                    e.target.closest('.card-btn-pill') ||
                    e.target.closest('.card-control-btn') ||
                    e.target.closest('#flipBtn') ||
                    e.target.closest('[onclick]')) {
                    return;
                }

                // Allow flipping anywhere else on the card (including front/back content)
                flipCard();
            });

            // Arrow buttons on the card faces
            document.getElementById('prevBtnFront').addEventListener('click', function(e) {
                e.stopPropagation();
                previousCard();
            });
            document.getElementById('nextBtnFront').addEventListener('click', function(e) {
                e.stopPropagation();
                nextCard();
            });
            document.getElementById('prevBtnBack').addEventListener('click', function(e) {
                e.stopPropagation();
                previousCard();
            });
            document.getElementById('nextBtnBack').addEventListener('click', function(e) {
                e.stopPropagation();
                nextCard();
            });
            // Top card buttons
            document.getElementById('reverseLangBtn').addEventListener('click', function(e) {
                e.stopPropagation();
                flipDirection();
            });
            document.getElementById('shuffleBtnTop').addEventListener('click', function(e) {
                e.stopPropagation();
                shuffleCards();
            });

            // Mobile button listeners
            document.getElementById('prevBtnFrontMobile').addEventListener('click', function(e) {
                e.stopPropagation();
                previousCard();
            });
            document.getElementById('nextBtnFrontMobile').addEventListener('click', function(e) {
                e.stopPropagation();
                nextCard();
            });
            document.getElementById('speakBtnMobile').addEventListener('click', function(e) {
                e.stopPropagation();
                const card = flashcards[currentIndex];
                if (card) speakWord(card.targetWord);
            });

            // Floating buttons (outside the card, for both mobile and desktop)
            document.getElementById('backBtnFloating').addEventListener('click', function(e) {
                e.stopPropagation();
                goBackToSetup();
            });
            document.getElementById('statsBtnFloating').addEventListener('click', function(e) {
                e.stopPropagation();
                showStatsModal();
            });

            // Desktop speak button
            document.getElementById('speakBtn').addEventListener('click', function(e) {
                e.stopPropagation();
                const card = flashcards[currentIndex];
                if (card) speakWord(card.targetWord);
            });

            document.getElementById('closeStatsModal').addEventListener('click', hideStatsModal);

            // Settings modal interactions
            document.getElementById('autoSpeakToggle').addEventListener('click', function() {
                speechEnabled = !speechEnabled;
                document.getElementById('autoSpeakStatus').textContent = speechEnabled ? 'ON' : 'OFF';
                document.getElementById('autoSpeakStatus').style.color = speechEnabled ? 'var(--accent-primary)' : 'var(--text-muted)';
            });

            // Refresh study set - delete progress for words in current set
            document.getElementById('refreshSetToggle').addEventListener('click', async function() {
                if (!currentUser || currentUser.isGuest) {
                    alert('You must be logged in to refresh your progress.');
                    return;
                }

                if (flashcards.length === 0) {
                    alert('No study set is currently loaded.');
                    return;
                }

                // Get the word ranks that are in the current flashcard set
                const wordsInSet = flashcards.map(card => ({
                    rank: card.rank,
                    word: card.targetWord
                }));

                const confirmMsg = `This will reset your progress for ${wordsInSet.length} words in the current study set. These words will appear again when you study this set. Continue?`;
                if (!confirm(confirmMsg)) {
                    return;
                }

                // Delete progress for each word in the set
                try {
                    for (const wordInfo of wordsInSet) {
                        // Remove from local progressData
                        if (progressData[wordInfo.rank]) {
                            delete progressData[wordInfo.rank];
                        }

                        // Delete from Google Sheets
                        await fetch(GOOGLE_SCRIPT_URL, {
                            method: 'POST',
                            body: JSON.stringify({
                                action: 'delete',
                                user: currentUser.initials,
                                wordRank: wordInfo.rank
                            })
                        });
                    }

                    alert(`Progress reset for ${wordsInSet.length} words. Go back to the menu and re-select this set to study the refreshed words.`);
                    hideSettingsModal();
                } catch (error) {
                    console.error('Failed to reset progress:', error);
                    alert('Failed to reset progress. Please try again.');
                }
            });

            // Click outside modal to close
            document.getElementById('statsModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    hideStatsModal();
                }
            });

            // Deck complete modal buttons
            document.getElementById('restartAllBtn').addEventListener('click', function() {
                hideDeckCompleteModal();
                restartAllCards();
            });

            document.getElementById('continueIncorrectBtn').addEventListener('click', function() {
                if (window.currentIncorrectCards && window.currentIncorrectCards.length > 0) {
                    hideDeckCompleteModal();
                    restartWithIncorrectCards(window.currentIncorrectCards);
                }
            });

            document.getElementById('markCompleteBtn').addEventListener('click', function() {
                hideDeckCompleteModal();
                // For now, just go back to setup (data storage not implemented)
                goBackToSetup();
            });

            // Click outside deck complete modal to close
            document.getElementById('deckCompleteModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    hideDeckCompleteModal();
                }
            });

            // Swipe gestures
            setupSwipeGestures();

            // Keyboard shortcuts
            setupKeyboardShortcuts();
        }

        function setupSwipeGestures() {
            const card = document.getElementById('flashcard');
            const incorrectIndicator = document.getElementById('incorrectIndicator');
            const correctIndicator = document.getElementById('correctIndicator');
            let touchStartX = 0;
            let touchStartY = 0;
            let currentX = 0;
            let currentY = 0;
            let isDragging = false;
            let hasMoved = false;
            let touchStartTime = 0;
            let maxMovement = 0; // Track maximum movement during touch
            let startedOnCircle = false; // Track if touch started on flip circle
            let touchZone = null; // Track which zone touch started in
            let wasFlippedAtStart = false; // Track flip state at touch start

            // Helper to determine touch zone (center vs edges)
            function getTouchZone(touchX, cardRect) {
                const relativeX = (touchX - cardRect.left) / cardRect.width;
                if (relativeX < 0.25) return 'left-edge';
                if (relativeX > 0.75) return 'right-edge';
                return 'center';
            }

            card.addEventListener('touchstart', function(e) {
                // Don't handle if touch is on buttons, links, or specific interactive elements
                if (e.target.closest('.nav-btn-inline') ||
                    e.target.closest('.link-btn') ||
                    e.target.closest('.card-control-btn') ||
                    e.target.closest('.card-action-small') ||
                    e.target.closest('.desktop-answer-btn') ||
                    e.target.closest('[onclick]')) {
                    return;
                }

                // Check if touch started on flip button or flip-back-area
                startedOnCircle = !!(e.target.closest('#flipBtn') || e.target.closest('.flip-back-area'));

                // Track flip state at start of touch
                wasFlippedAtStart = card.classList.contains('flipped');

                // Get touch zone for zone-based gesture handling
                const cardRect = card.getBoundingClientRect();
                touchZone = getTouchZone(e.touches[0].clientX, cardRect);

                // On back side, allow swiping from card-details area (remove the restriction)
                // Only block actual interactive elements like onclick handlers
                if (wasFlippedAtStart) {
                    // Back side: allow swipe from anywhere except buttons/links
                    // This enables swiping even from card-details area
                } else {
                    // Front side: standard handling
                    if (e.target.closest('.card-front') || e.target.closest('#flipBtn')) {
                        // Allow touch to proceed
                    } else {
                        return;
                    }
                }

                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                currentX = touchStartX;
                currentY = touchStartY;
                isDragging = true;
                hasMoved = false;
                maxMovement = 0;
                touchStartTime = Date.now();
                card.classList.add('swiping');
            }, { passive: true });

            card.addEventListener('touchmove', function(e) {
                if (!isDragging) return;

                currentX = e.touches[0].clientX;
                currentY = e.touches[0].clientY;

                const diffX = currentX - touchStartX;
                const diffY = currentY - touchStartY;
                const totalMovement = Math.abs(diffX) + Math.abs(diffY);
                maxMovement = Math.max(maxMovement, totalMovement);

                // Only mark as moved if significant movement (raised threshold)
                if (Math.abs(diffX) > 5 || Math.abs(diffY) > 5) {
                    hasMoved = true;
                }

                // Horizontal swipes - move card and show indicators
                if (Math.abs(diffX) > Math.abs(diffY) && hasMoved) {
                    const rotation = diffX / 20; // Rotate based on swipe distance

                    // Preserve flip state when moving card
                    const isFlipped = card.classList.contains('flipped');
                    if (isFlipped) {
                        card.style.transform = `translateX(${diffX}px) rotate(${rotation}deg) rotateY(180deg)`;
                    } else {
                        card.style.transform = `translateX(${diffX}px) rotate(${rotation}deg)`;
                    }

                    // Show indicators based on swipe direction
                    if (diffX > 50) {
                        correctIndicator.classList.add('visible');
                        incorrectIndicator.classList.remove('visible');
                    } else if (diffX < -50) {
                        incorrectIndicator.classList.add('visible');
                        correctIndicator.classList.remove('visible');
                    } else {
                        correctIndicator.classList.remove('visible');
                        incorrectIndicator.classList.remove('visible');
                    }
                }
            }, { passive: true });

            card.addEventListener('touchend', function(e) {
                if (!isDragging) return;
                isDragging = false;

                const diffX = currentX - touchStartX;
                const diffY = currentY - touchStartY;
                const touchDuration = Date.now() - touchStartTime;

                // Check if indicator is visible BEFORE removing it
                const indicatorWasVisible = correctIndicator.classList.contains('visible') || incorrectIndicator.classList.contains('visible');
                const swipeDirection = correctIndicator.classList.contains('visible') ? 'correct' : 'incorrect';

                card.classList.remove('swiping');
                correctIndicator.classList.remove('visible');
                incorrectIndicator.classList.remove('visible');

                // Reset card transform
                card.style.transform = '';

                // If indicator was visible, auto-complete the swipe
                if (indicatorWasVisible) {
                    handleSwipeAction(swipeDirection);
                    return;
                }

                // Tap detection - very strict threshold
                const isTap = touchDuration < 200 && maxMovement < 7.5;
                const isQuickTap = touchDuration < 300 && maxMovement < 15;

                // ========== FRONT SIDE LOGIC (flip priority) ==========
                if (!wasFlippedAtStart) {
                    // If touch started on flip circle, only allow flipping
                    if (startedOnCircle) {
                        if (touchDuration < 500 && maxMovement < 100) {
                            flipCard();
                        }
                        return;
                    }

                    // Center zone: flip is priority, ignore swipes
                    if (touchZone === 'center') {
                        // Only flip on clear taps, not on any small movement
                        if (isTap || isQuickTap) {
                            flipCard();
                        }
                        // Any other movement is ignored (prevents accidental partial swipes)
                        return;
                    }

                    // Edge zones: swipe takes priority
                    const edgeSwipeThreshold = 5; // Reduced 75% from 20 for even easier swiping
                    const isEdgeSwipe = Math.abs(diffX) > edgeSwipeThreshold && Math.abs(diffX) > Math.abs(diffY);

                    if (isEdgeSwipe) {
                        handleSwipeAction(diffX > 0 ? 'correct' : 'incorrect');
                    } else if (isTap) {
                        flipCard(); // Tap on edge still flips
                    }
                    return;
                }

                // ========== BACK SIDE LOGIC (swipe priority) ==========
                const backSwipeThreshold = 5; // Reduced 75% from 20 for even easier swiping on back
                const isHorizontalSwipe = Math.abs(diffX) > backSwipeThreshold && Math.abs(diffX) > Math.abs(diffY) * 1.2;
                const isVerticalSwipe = Math.abs(diffY) > backSwipeThreshold && Math.abs(diffY) > Math.abs(diffX) * 1.2;

                if (isHorizontalSwipe) {
                    // Horizontal swipe - correct/incorrect
                    handleSwipeAction(diffX > 0 ? 'correct' : 'incorrect');
                } else if (isVerticalSwipe) {
                    // Vertical swipe - cycle through meanings for multi-meaning cards
                    const currentCard = flashcards[currentIndex];
                    if (currentCard && currentCard.isMultiMeaning) {
                        if (diffY < 0) {
                            currentMeaningIndex = (currentMeaningIndex + 1) % currentCard.meanings.length;
                        } else {
                            currentMeaningIndex = (currentMeaningIndex - 1 + currentCard.meanings.length) % currentCard.meanings.length;
                        }
                        updateCard();
                        // Auto-speak the new meaning
                        const meaning = currentCard.meanings[currentMeaningIndex];
                        if (meaning && meaning.meaning) {
                            if (isFlipped) {
                                // English â†’ Target mode: back shows target, speak target
                                speakWord(currentCard.targetWord, false);
                            } else {
                                // Target â†’ English mode: back shows English, speak English
                                speakWord(meaning.meaning, true);
                            }
                        }
                    } else if (currentCard && currentCard.sentences) {
                        if (diffY < 0) {
                            currentSentenceIndex = (currentSentenceIndex + 1) % currentCard.sentences.length;
                        } else {
                            currentSentenceIndex = (currentSentenceIndex - 1 + currentCard.sentences.length) % currentCard.sentences.length;
                        }
                        updateCard();
                    }
                } else if (startedOnCircle && maxMovement < 50) {
                    // Only flip back if specifically tapping the flip area
                    flipCard();
                }
                // Other gestures on back side are ignored (prevents accidental flips)
            }, { passive: true });
        }

        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', function(e) {
                // Ignore if typing in an input field
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }

                // Left arrow = incorrect
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    handleSwipeAction('incorrect');
                }
                // Right arrow = correct
                else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    handleSwipeAction('correct');
                }
                // Space or Enter = flip card
                else if (e.key === ' ' || e.key === 'Enter') {
                    e.preventDefault();
                    flipCard();
                }
            });
        }

        function handleSwipeAction(result) {
            const card = document.getElementById('flashcard');
            const isFlipped = card.classList.contains('flipped');

            // Record the result
            recordCardResult(result);

            // Animate the card off screen (maintain flip state during animation)
            if (result === 'correct') {
                card.classList.add('swipe-correct');
            } else {
                card.classList.add('swipe-incorrect');
            }

            // Wait for animation to complete, then move to next card
            setTimeout(() => {
                card.classList.remove('swipe-correct', 'swipe-incorrect');
                card.style.transform = '';

                // Move to next card
                if (currentIndex < flashcards.length - 1) {
                    currentIndex++;
                    currentSentenceIndex = 0; // Reset sentence index for new card
                    currentMeaningIndex = 0; // Reset meaning index for new card
                    updateCard();
                    // Always show front side of next card
                    document.getElementById('flashcard').classList.remove('flipped');
                } else {
                    // End of deck - show options
                    showEndOfDeckOptions();
                }
            }, 300);
        }

        function showEndOfDeckOptions() {
            const incorrectCards = Object.keys(stats.cardStats)
                .filter(idx => stats.cardStats[idx].incorrect > stats.cardStats[idx].correct)
                .map(Number);

            const totalAttempts = stats.correct + stats.incorrect;
            const accuracy = totalAttempts > 0 ? Math.round((stats.correct / totalAttempts) * 100) : 0;

            // Update modal content
            document.getElementById('completeCorrect').textContent = stats.correct;
            document.getElementById('completeIncorrect').textContent = stats.incorrect;
            document.getElementById('completeAccuracy').textContent = `Accuracy: ${accuracy}%`;

            const continueBtn = document.getElementById('continueIncorrectBtn');
            const messageEl = document.getElementById('completeMessage');

            if (incorrectCards.length > 0) {
                messageEl.textContent = `${incorrectCards.length} card${incorrectCards.length > 1 ? 's' : ''} to review`;
                continueBtn.disabled = false;
                continueBtn.querySelector('span:last-child').textContent = `Review ${incorrectCards.length} Mistake${incorrectCards.length > 1 ? 's' : ''}`;
            } else {
                messageEl.innerHTML = `<span style="color: var(--accent-green); font-weight: 600;">Perfect score! ðŸŽ‰</span>`;
                continueBtn.disabled = true;
                continueBtn.querySelector('span:last-child').textContent = 'No Mistakes';
            }

            // Store incorrect cards for later use
            window.currentIncorrectCards = incorrectCards;

            // Show the modal
            document.getElementById('deckCompleteModal').classList.remove('hidden');
        }

        function hideDeckCompleteModal() {
            document.getElementById('deckCompleteModal').classList.add('hidden');
        }

        function restartWithIncorrectCards(incorrectIndices) {
            // Create new deck with only incorrect cards
            const incorrectFlashcards = incorrectIndices.map(idx => flashcards[idx]);

            // Reset stats
            stats.correct = 0;
            stats.incorrect = 0;
            stats.total = 0;
            stats.studied = new Set();
            stats.cardStats = {};

            // Set new flashcards array
            flashcards = incorrectFlashcards;
            currentIndex = 0;
            currentSentenceIndex = 0;

            updateCard();
            document.getElementById('flashcard').classList.remove('flipped');
        }

        function restartAllCards() {
            // Reset stats
            stats.correct = 0;
            stats.incorrect = 0;
            stats.total = 0;
            stats.studied = new Set();
            stats.cardStats = {};

            currentIndex = 0;
            currentSentenceIndex = 0;

            updateCard();
            document.getElementById('flashcard').classList.remove('flipped');
        }

        function recordCardResult(result) {
            // Initialize card stats if not exists
            if (!stats.cardStats[currentIndex]) {
                stats.cardStats[currentIndex] = { correct: 0, incorrect: 0 };
            }

            // Record the result
            const isCorrect = result === 'correct';
            if (isCorrect) {
                stats.correct++;
                stats.cardStats[currentIndex].correct++;
            } else {
                stats.incorrect++;
                stats.cardStats[currentIndex].incorrect++;
            }
            stats.total++;

            // Save progress to Google Sheets or LocalStorage
            const currentCard = flashcards[currentIndex];
            if (currentCard && currentCard.rank) {
                saveWordProgress(currentCard, isCorrect);
            }
        }

        function showFloatingBtns(show) {
            const btns = document.getElementById('floatingBtns');
            const statsBtnPill = document.getElementById('statsBtnPill');
            if (btns) {
                if (show) {
                    btns.classList.add('visible');
                    // Hide stats button in pill when in flashcard view
                    if (statsBtnPill) {
                        statsBtnPill.style.display = 'none';
                    }
                } else {
                    btns.classList.remove('visible');
                    // Show stats button in pill when back on setup page (if applicable)
                    updateTotalStatsButtonVisibility();
                }
            }
        }

        function goBackToSetup() {
            // Hide app content, show setup
            const appContent = document.getElementById('appContent');
            const setupPanel = document.getElementById('setupPanel');

            appContent.classList.add('hidden');
            setupPanel.classList.remove('hidden');
            setupPanel.style.display = 'block';

            // Hide mobile floating buttons
            showFloatingBtns(false);

            // Scroll to top
            document.querySelector('.container').scrollTop = 0;

            // Keep the language selected and show subsequent steps
            // Don't reset the language - user can pick a new set for the same language
            document.getElementById('step2').style.display = 'block';
            document.getElementById('step4').style.display = 'none';

            // Reset only the range/set selections, not the level
            document.querySelectorAll('.range-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            document.querySelectorAll('.range-btn-new').forEach(btn => {
                btn.classList.remove('selected');
            });
            selectedRanges = [];
            flashcards = [];
            currentIndex = 0;
            currentSentenceIndex = 0;
            currentMeaningIndex = 0;
            isFlipped = false;

            // Re-render level selector to show updated progress
            renderLevelSelector(selectedLanguage);
            updateLemmaToggleVisibility();

            // Reset card state
            const flashcardEl = document.getElementById('flashcard');
            if (flashcardEl) {
                flashcardEl.classList.remove('flipped');
            }

            stats = {
                studied: new Set(),
                correct: 0,
                incorrect: 0,
                total: 0,
                cardStats: {}
            };
        }

        function showStatsModal() {
            document.getElementById('statsModal').classList.remove('hidden');
            updateStatsModal();
        }

        function hideStatsModal() {
            document.getElementById('statsModal').classList.add('hidden');
        }

        function showSettingsModal() {
            showSettingsModalWithTab('settings');
        }

        function showSettingsModalWithTab(tabName) {
            // Update settings tab
            document.getElementById('autoSpeakStatus').textContent = speechEnabled ? 'ON' : 'OFF';
            document.getElementById('autoSpeakStatus').style.color = speechEnabled ? 'var(--accent-primary)' : 'var(--text-muted)';

            // Show/hide refresh set option based on whether a study set is loaded and user is logged in
            const refreshSetToggle = document.getElementById('refreshSetToggle');
            if (currentUser && !currentUser.isGuest && flashcards.length > 0) {
                refreshSetToggle.style.display = 'flex';
            } else {
                refreshSetToggle.style.display = 'none';
            }

            // Update account tab with current user
            const userBadge = currentUser ? (currentUser.isGuest ? 'GUEST' : currentUser.initials) : 'GUEST';
            document.getElementById('accountUserBadge').textContent = userBadge;

            // Update stats tab
            updateStatsTab();

            // Switch to specified tab
            document.querySelectorAll('.settings-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.settings-tab[data-tab="${tabName}"]`).classList.add('active');
            document.querySelectorAll('.settings-tab-content').forEach(c => c.classList.remove('active'));
            const tabContentId = tabName === 'settings' ? 'settingsTabContent' :
                                 tabName === 'stats' ? 'statsTabContent' : 'accountTabContent';
            document.getElementById(tabContentId).classList.add('active');

            document.getElementById('settingsModal').classList.remove('hidden');
        }

        function updateStatsTab() {
            // Update language name
            const langConfig = config.languages[selectedLanguage];
            const langName = langConfig ? langConfig.name : selectedLanguage;
            document.getElementById('statsTabLanguage').textContent = langName;

            // Calculate total stats from progressData for the selected language
            let wordsCorrect = 0;
            let wordsSeen = 0;

            if (progressData) {
                Object.values(progressData).forEach(data => {
                    if (data.language === selectedLanguage) {
                        wordsSeen++;
                        if (data.correct > 0) {
                            wordsCorrect++;
                        }
                    }
                });
            }

            document.getElementById('statsTabWordsCorrect').textContent = wordsCorrect;
            document.getElementById('statsTabWordsSeen').textContent = wordsSeen;
        }

        function hideSettingsModal() {
            document.getElementById('settingsModal').classList.add('hidden');
        }

        function showTotalStatsModal() {
            // Update language name in the header
            const langConfig = config.languages[selectedLanguage];
            const langName = langConfig ? langConfig.name : selectedLanguage;
            document.getElementById('totalStatsLanguage').textContent = langName;

            // Calculate total stats from progressData for the selected language
            let wordsCorrect = 0;
            let wordsSeen = 0;

            if (progressData) {
                Object.values(progressData).forEach(data => {
                    if (data.language === selectedLanguage) {
                        wordsSeen++;
                        if (data.correct > 0) {
                            wordsCorrect++;
                        }
                    }
                });
            }

            document.getElementById('totalWordsCorrect').textContent = wordsCorrect;
            document.getElementById('totalWordsSeen').textContent = wordsSeen;

            document.getElementById('totalStatsModal').classList.remove('hidden');
        }

        function hideTotalStatsModal() {
            document.getElementById('totalStatsModal').classList.add('hidden');
        }

        function updateTotalStatsButtonVisibility() {
            const btn = document.getElementById('statsBtnPill');
            if (btn) {
                // Show if logged in and progressData has data for the selected language
                if (currentUser && !currentUser.isGuest && progressData) {
                    const hasData = Object.values(progressData).some(
                        data => data.language === selectedLanguage
                    );
                    btn.style.display = hasData ? 'flex' : 'none';
                } else {
                    btn.style.display = 'none';
                }
            }
        }

        function updateStatsModal() {
            document.getElementById('cardsStudied').textContent = stats.studied.size;
            document.getElementById('totalCardsStats').textContent = flashcards.length;
            const progress = flashcards.length > 0 ? Math.round((stats.studied.size / flashcards.length) * 100) : 0;
            document.getElementById('progressPercent').textContent = progress + '%';

            document.getElementById('correctCount').textContent = stats.correct;
            document.getElementById('incorrectCount').textContent = stats.incorrect;

            const totalAttempts = stats.correct + stats.incorrect;
            const accuracy = totalAttempts > 0 ? Math.round((stats.correct / totalAttempts) * 100) : 0;
            document.getElementById('accuracyPercent').textContent = totalAttempts > 0 ? accuracy + '%' : '-';
        }

        function updateCard() {
            const card = flashcards[currentIndex];
            const langConfig = config.languages[selectedLanguage];

            // Update reverse button text
            updateReverseButton();

            // Reset meaning index if out of bounds
            if (card.isMultiMeaning && currentMeaningIndex >= card.meanings.length) {
                currentMeaningIndex = 0;
            }

            // Get the current meaning for multi-meaning cards
            const currentMeaning = card.isMultiMeaning ? card.meanings[currentMeaningIndex] : null;

            // Determine what to show on front and back based on flip direction
            let frontText, backWord, backTranslation, exampleSentence, exampleTranslation;

            if (card.isMultiMeaning) {
                // Multi-meaning format
                if (isFlipped) {
                    // English â†’ Target language
                    frontText = currentMeaning.meaning;
                    backWord = card.targetWord;
                    backTranslation = currentMeaning.meaning;
                    exampleSentence = currentMeaning.englishSentence;
                    exampleTranslation = currentMeaning.targetSentence;
                } else {
                    // Target language â†’ English (normal)
                    frontText = card.targetWord;
                    backWord = card.targetWord;
                    backTranslation = currentMeaning.meaning;
                    exampleSentence = currentMeaning.targetSentence;
                    exampleTranslation = currentMeaning.englishSentence;
                }
            } else {
                // Legacy format - get current sentence from sentences array
                const currentSentence = card.sentences && card.sentences.length > 0
                    ? card.sentences[currentSentenceIndex % card.sentences.length]
                    : { target: card.targetSentence, english: card.englishSentence };

                if (isFlipped) {
                    // English â†’ Target language
                    frontText = card.translation;
                    backWord = card.targetWord;
                    backTranslation = card.translation;
                    exampleSentence = currentSentence.english;
                    exampleTranslation = currentSentence.target;
                } else {
                    // Target language â†’ English (normal)
                    frontText = card.targetWord;
                    backWord = card.targetWord;
                    backTranslation = card.translation;
                    exampleSentence = currentSentence.target;
                    exampleTranslation = currentSentence.english;
                }
            }

            document.getElementById('frontWord').textContent = frontText;

            // Display lemma on front if different from target word
            // But hide it when reversed (English â†’ Target) as it gives away the answer
            const frontLemmaEl = document.getElementById('frontLemma');
            if (!isFlipped && card.lemma && card.lemma !== card.targetWord) {
                frontLemmaEl.textContent = card.lemma;
                frontLemmaEl.style.display = 'block';
            } else {
                frontLemmaEl.style.display = 'none';
            }

            // Store ranking as data attribute on card for console access
            const flashcardEl = document.getElementById('flashcard');
            if (card.rank !== undefined) {
                flashcardEl.setAttribute('data-rank', card.rank);
            } else {
                flashcardEl.setAttribute('data-rank', '');
            }

            // Display ranking on front card
            const frontRankingEl = document.getElementById('frontRanking');
            if (card.rank !== undefined) {
                frontRankingEl.textContent = `Rank: ${card.rank}`;
                frontRankingEl.style.display = 'block';
            } else {
                frontRankingEl.style.display = 'none';
            }

            // Build back content with lemma in brackets if different
            let wordDisplay = backWord;
            if (card.isMultiMeaning && card.lemma && card.lemma !== card.targetWord) {
                wordDisplay = `${backWord} <span style="color: var(--accent-secondary); font-size: 28px;">(${card.lemma})</span>`;
            }

            let backHTML = `
                <div style="text-align: center; margin-bottom: 20px;">
                    <div class="flip-back-area" id="flipBackArea">
                        <div style="font-size: 42px; color: var(--accent-primary); font-weight: bold;">${wordDisplay}</div>
                    </div>
                </div>
            `;

            // For multi-meaning cards, show all meanings on the back
            if (card.isMultiMeaning) {

                backHTML += `<div style="width: 100%; margin-bottom: 15px;">`;
                card.meanings.forEach((m, idx) => {
                    const isSelected = idx === currentMeaningIndex;
                    const bgColor = isSelected ? 'rgba(var(--accent-primary-rgb), 0.5)' : 'var(--bg-tertiary)';
                    const textColor = isSelected ? 'var(--text-primary)' : 'var(--text-primary)';
                    const borderStyle = isSelected ? 'border: 2px solid var(--accent-primary);' : '';
                    backHTML += `
                        <div style="display: flex; align-items: center; padding: 10px 15px; margin-bottom: 8px; background: ${bgColor}; ${borderStyle} border-radius: 8px; cursor: pointer;" onclick="selectMeaning(${idx})">
                            <span style="font-family: var(--font-data); font-size: 12px; color: ${isSelected ? 'var(--accent-secondary)' : 'var(--accent-secondary)'}; min-width: 45px;">${Math.round(m.percentage * 100)}%</span>
                            <span style="font-size: 16px; font-weight: 600; color: ${textColor}; flex: 1;">${m.meaning}</span>
                            <span style="font-family: var(--font-data); font-size: 11px; color: ${isSelected ? 'var(--text-secondary)' : 'var(--text-muted)'}; text-transform: uppercase;">${m.pos}</span>
                        </div>
                    `;
                });
                backHTML += `</div>`;

                // Show current sentence
                if (currentMeaning && currentMeaning.targetSentence) {
                    backHTML += `
                        <div class="sentence" style="text-align: center;">
                            <div style="margin-bottom: 8px;">${currentMeaning.targetSentence}</div>
                            <div class="translation">${currentMeaning.englishSentence}</div>
                        </div>
                    `;
                }
            } else {
                // Legacy format
                backHTML += `<div style="font-size: 28px; color: var(--text-primary); margin-top: 12px; font-weight: 600; text-align: center; margin-bottom: 20px;">${backTranslation}</div>`;

                // Show base form if different from displayed word
                if (card.inflectedForm && card.baseForm !== card.targetWord) {
                    backHTML += `<div style="margin-bottom: 15px; font-size: 16px; text-align: center; color: #ffffff;"><strong style="color: var(--accent-secondary);">Base form:</strong> ${card.baseForm}</div>`;
                }

                // Show example sentences if available
                const sentenceCount = card.sentences ? card.sentences.length : 1;
                if (sentenceCount > 0) {
                    const showEmpty = !exampleSentence && !exampleTranslation;
                    const sentenceIndicator = sentenceCount > 1 ? `
                        <div style="display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 8px;">
                            <span style="color: var(--accent-primary); font-size: 18px;">â†‘</span>
                            <span style="color: var(--text-muted); font-size: 12px;">${currentSentenceIndex + 1} / ${sentenceCount}</span>
                            <span style="color: var(--accent-primary); font-size: 18px;">â†“</span>
                        </div>
                    ` : '';

                    backHTML += `
                        ${sentenceIndicator}
                        <div class="sentence" style="min-height: 80px; text-align: center;">
                            ${exampleSentence ? `<div style="margin-bottom: 8px;">${exampleSentence}</div>` : ''}
                            ${exampleTranslation ? `<div class="translation">${exampleTranslation}</div>` : ''}
                            ${showEmpty ? `<div style="color: var(--text-muted); text-align: center; padding: 20px;">(No example sentence)</div>` : ''}
                        </div>
                    `;
                }
            }

            // Reference links (exclude wordReference, use shortened labels)
            const linkLabels = {
                'spanishDict': 'SpanishDict',
                'reverso': 'Reverso',
                'conjugation': 'Conjugate'
            };

            // Determine if current word is a verb
            let isVerb = false;
            if (card.isMultiMeaning && currentMeaning) {
                // For multi-meaning cards, check the current meaning's POS
                const pos = currentMeaning.pos ? currentMeaning.pos.toLowerCase() : '';
                isVerb = pos.includes('verb') || pos === 'v' || pos === 'vb';
            }

            backHTML += `<div class="links-section" id="linksSection">`;

            for (const [key, url] of Object.entries(card.links)) {
                if (key === 'wordReference') continue; // Skip wordReference
                // Skip conjugation link for non-verbs
                if (key === 'conjugation' && !isVerb) continue;
                const label = linkLabels[key] || key;
                backHTML += `<a href="${url}" target="_blank" class="link-btn">${label}</a>`;
            }

            backHTML += `</div>`;

            document.getElementById('backContent').innerHTML = backHTML;

            // Update frequency display
            stats.studied.add(currentIndex);
            updateStats();

            // Update disabled state for all nav buttons
            const isPrevDisabled = currentIndex === 0;
            const isNextDisabled = currentIndex === flashcards.length - 1;
            document.getElementById('prevBtnFront').disabled = isPrevDisabled;
            document.getElementById('nextBtnFront').disabled = isNextDisabled;
            document.getElementById('prevBtnBack').disabled = isPrevDisabled;
            document.getElementById('nextBtnBack').disabled = isNextDisabled;
            document.getElementById('prevBtnFrontMobile').disabled = isPrevDisabled;
            document.getElementById('nextBtnFrontMobile').disabled = isNextDisabled;

            // Setup top answer buttons (desktop only)
            const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
            if (!isTouchDevice) {
                const correctBtnTop = document.getElementById('correctBtnTop');
                const incorrectBtnTop = document.getElementById('incorrectBtnTop');

                if (correctBtnTop && incorrectBtnTop) {
                    correctBtnTop.style.display = 'flex';
                    incorrectBtnTop.style.display = 'flex';

                    correctBtnTop.onclick = function(e) {
                        e.stopPropagation();
                        handleSwipeAction('correct');
                    };
                    incorrectBtnTop.onclick = function(e) {
                        e.stopPropagation();
                        handleSwipeAction('incorrect');
                    };
                }
            }

            // Speak the word if showing target language on front
            if (!isFlipped) {
                speakWord(card.targetWord);
            }
        }

        function flipCard() {
            const flashcardEl = document.getElementById('flashcard');
            const wasFlipped = flashcardEl.classList.contains('flipped');
            flashcardEl.classList.toggle('flipped');
            const isNowFlipped = flashcardEl.classList.contains('flipped');

            const card = flashcards[currentIndex];
            if (!card) return;

            // Auto-speak based on flip state and language direction
            if (isNowFlipped) {
                // Just flipped to BACK of card
                if (isFlipped) {
                    // English â†’ Target mode: back shows target word, speak target
                    speakWord(card.targetWord, false);
                } else {
                    // Target â†’ English mode: back shows English, speak English meaning
                    const meaning = card.meanings[currentMeaningIndex];
                    if (meaning && meaning.meaning) {
                        speakWord(meaning.meaning, true);
                    }
                }
            } else {
                // Just flipped to FRONT of card
                if (isFlipped) {
                    // English â†’ Target mode: front shows English, speak English
                    const meaning = card.meanings[currentMeaningIndex];
                    if (meaning && meaning.meaning) {
                        speakWord(meaning.meaning, true);
                    }
                } else {
                    // Target â†’ English mode: front shows target word, speak target
                    speakWord(card.targetWord, false);
                }
            }
        }

        function selectMeaning(index) {
            currentMeaningIndex = index;
            updateCard();
            // Auto-speak the selected meaning
            const card = flashcards[currentIndex];
            if (card && card.meanings[index]) {
                const meaning = card.meanings[index];
                if (isFlipped) {
                    // English â†’ Target mode: back shows target, speak target
                    speakWord(card.targetWord, false);
                } else {
                    // Target â†’ English mode: back shows English, speak English
                    speakWord(meaning.meaning, true);
                }
            }
        }

        function previousCard() {
            if (currentIndex > 0) {
                currentIndex--;
                currentMeaningIndex = 0; // Reset meaning selection
                updateCard();
                document.getElementById('flashcard').classList.remove('flipped');
            }
        }

        function nextCard() {
            if (currentIndex < flashcards.length - 1) {
                currentIndex++;
                currentMeaningIndex = 0; // Reset meaning selection
                updateCard();
                document.getElementById('flashcard').classList.remove('flipped');
            }
        }

        function shuffleCards() {
            for (let i = flashcards.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [flashcards[i], flashcards[j]] = [flashcards[j], flashcards[i]];
            }
            currentIndex = 0;
            updateCard();
        }

        function flipDirection() {
            isFlipped = !isFlipped;
            updateCard();
            document.getElementById('flashcard').classList.remove('flipped');
        }

        function updateReverseButton() {
            const reverseBtn = document.getElementById('reverseLangBtn');
            if (!reverseBtn) return;

            // Map language codes to flag emojis
            const flagMap = {
                'dutch': 'ðŸ‡³ðŸ‡±',
                'polish': 'ðŸ‡µðŸ‡±',
                'spanish': 'ðŸ‡ªðŸ‡¸',
                'italian': 'ðŸ‡®ðŸ‡¹',
                'french': 'ðŸ‡«ðŸ‡·',
                'russian': 'ðŸ‡·ðŸ‡º',
                'swedish': 'ðŸ‡¸ðŸ‡ª'
            };

            const targetFlag = flagMap[selectedLanguage] || 'ðŸ‡¸ðŸ‡ª';
            const englishFlag = 'ðŸ‡¬ðŸ‡§';

            if (isFlipped) {
                // English â†’ Target language
                reverseBtn.innerHTML = `${englishFlag} â†’ ${targetFlag}`;
                reverseBtn.title = `Reverse to ${config.languages[selectedLanguage]?.name || selectedLanguage} â†’ English`;
            } else {
                // Target language â†’ English (normal)
                reverseBtn.innerHTML = `${targetFlag} â†’ ${englishFlag}`;
                reverseBtn.title = `Reverse to English â†’ ${config.languages[selectedLanguage]?.name || selectedLanguage}`;
            }
        }

        function updateStats() {
            // Stats are now displayed in modal only
        }
    </script>
</body>
</html>