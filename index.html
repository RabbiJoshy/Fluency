<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#0a0e14">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Flashcards">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='20' fill='%23667eea'/%3E%3Ctext x='50' y='70' font-size='60' text-anchor='middle' fill='white'%3EðŸ“š%3C/text%3E%3C/svg%3E">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,wght@0,400;0,500;0,600;0,700;1,400&family=JetBrains+Mono:wght@400;500;600&family=Space+Grotesk:wght@500;600;700&display=swap" rel="stylesheet">
    <title>Language Flashcards</title>
    <style>
        :root {
            /* Dark industrial base palette */
            --bg-primary: #0a0e14;
            --bg-secondary: #121820;
            --bg-tertiary: #1a222d;
            --bg-card: #1e2732;
            --bg-card-hover: #252f3c;

            /* Text colors - high contrast */
            --text-primary: #ffffff;
            --text-secondary: #e0e4ea;
            --text-muted: #a0a8b4;

            /* Accent colors - industrial/energy */
            --accent-orange: #ff6b35;
            --accent-amber: #f5a623;
            --accent-blue: #4a9eff;
            --accent-green: #00d4aa;

            /* Language-specific theme colors (dynamically updated) */
            --accent-primary: #C8102E;
            --accent-secondary: #FFCC00;

            /* Semantic colors */
            --success: #00d4aa;
            --error: #ff5252;
            --warning: #f5a623;

            /* Borders and dividers */
            --border-color: #2a3441;
            --border-light: #3a4553;

            /* Glow effects */
            --glow-orange: rgba(255, 107, 53, 0.3);
            --glow-blue: rgba(74, 158, 255, 0.3);
            --glow-green: rgba(0, 212, 170, 0.3);

            /* Fonts */
            --font-reading: 'DM Sans', -apple-system, BlinkMacSystemFont, sans-serif;
            --font-emphasis: 'Space Grotesk', -apple-system, BlinkMacSystemFont, sans-serif;
            --font-data: 'JetBrains Mono', monospace;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-reading);
            background: var(--bg-primary);
            background-image:
                radial-gradient(ellipse at top, var(--bg-secondary) 0%, transparent 50%),
                radial-gradient(ellipse at bottom right, rgba(255, 107, 53, 0.05) 0%, transparent 40%);
            min-height: 100vh;
            height: 100vh;
            padding: 0;
            margin: 0;
            color: var(--text-primary);
            overflow: hidden;
            touch-action: manipulation;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
        }

        .container {
            max-width: 100%;
            width: 100%;
            height: 100%;
            margin: 0 auto;
            padding: 10px;
            box-sizing: border-box;
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
        }

        @media (min-width: 768px) {
            .container {
                max-width: 800px;
                padding: 20px;
            }
        }

        .header {
            text-align: center;
            color: white;
            padding: 20px 0;
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .mode-btn {
            flex: 1;
            min-width: 120px;
            padding: 12px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            color: var(--text-secondary);
        }

        .mode-btn:hover {
            transform: translateY(-2px);
            background: var(--bg-card-hover);
            border-color: var(--accent-primary);
        }

        .mode-btn.active {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-color: var(--accent-primary);
        }

        .card-container {
            perspective: 1000px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px 0;
            overflow: hidden;
            touch-action: pan-x pan-y;
            -webkit-user-select: none;
            user-select: none;
        }

        .card {
            width: 100%;
            height: auto;
            min-height: 460px;
            max-height: calc(100vh - 100px);
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            cursor: pointer;
            touch-action: none;
            -webkit-user-drag: none;
        }

        .card.swiping {
            transition: none;
        }

        .card.swipe-correct {
            animation: swipeRight 0.3s ease-out forwards;
        }

        .card.swipe-incorrect {
            animation: swipeLeft 0.3s ease-out forwards;
        }

        .card.flipped.swipe-correct {
            animation: swipeRightFlipped 0.3s ease-out forwards;
        }

        .card.flipped.swipe-incorrect {
            animation: swipeLeftFlipped 0.3s ease-out forwards;
        }

        @keyframes swipeRight {
            to {
                transform: translateX(150%) rotate(20deg);
                opacity: 0;
            }
        }

        @keyframes swipeLeft {
            to {
                transform: translateX(-150%) rotate(-20deg);
                opacity: 0;
            }
        }

        @keyframes swipeRightFlipped {
            to {
                transform: translateX(150%) rotate(20deg) rotateY(180deg);
                opacity: 0;
            }
        }

        @keyframes swipeLeftFlipped {
            to {
                transform: translateX(-150%) rotate(-20deg) rotateY(180deg);
                opacity: 0;
            }
        }

        @media (min-width: 768px) {
            .card {
                max-height: calc(100vh - 120px);
            }
        }

        .swipe-indicator {
            position: absolute;
            top: 50%;
            font-size: 72px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
            pointer-events: none;
            transform: translateY(-50%);
        }

        .swipe-indicator.correct {
            right: 20px;
            color: var(--accent-green);
            text-shadow: 0 0 20px var(--glow-green);
        }

        .swipe-indicator.incorrect {
            left: 20px;
            color: var(--error);
            text-shadow: 0 0 20px rgba(255, 82, 82, 0.5);
        }

        .swipe-indicator.visible {
            opacity: 1;
        }

        .card.flipped {
            transform: rotateY(180deg);
        }

        /* Hide front card controls when flipped */
        .card.flipped .card-front {
            visibility: hidden;
            opacity: 0;
            pointer-events: none;
        }

        .card.flipped .card-back {
            visibility: visible;
            opacity: 1;
            pointer-events: auto;
        }

        /* Ensure back is hidden when not flipped */
        .card-back {
            opacity: 0;
        }

        .card-front {
            visibility: visible;
            pointer-events: auto;
        }

        .card-back {
            visibility: hidden;
            pointer-events: none;
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 16px;
            padding: 30px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-top: 3px solid transparent;
            border-image: linear-gradient(to right, var(--accent-primary), var(--accent-secondary)) 1;
            border-image-slice: 1 0 0 0;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4), 0 0 1px rgba(255, 107, 53, 0.1);
            overflow: hidden;
        }

        @media (max-width: 767px) {
            .card-face {
                padding: 20px;
            }
        }

        .card-back {
            transform: rotateY(180deg);
        }

        .card-word {
            font-family: var(--font-emphasis);
            font-size: 64px;
            font-weight: 700;
            margin-bottom: 20px;
            color: var(--accent-primary);
            text-align: center;
        }

        .card-lemma {
            font-family: var(--font-reading);
            font-size: 22px;
            color: var(--accent-secondary);
            text-align: center;
            margin-bottom: 15px;
            font-weight: 500;
        }

        .card-ranking {
            font-family: var(--font-data);
            font-size: 16px;
            color: var(--text-muted);
            text-align: center;
            letter-spacing: 0.5px;
        }

        .card-control-btn {
            padding: 8px 14px;
            background: #1a1a1a;
            color: var(--text-primary);
            border: 1.5px solid #333333;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 700;
            font-family: var(--font-emphasis);
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 50px;
            height: 38px;
            letter-spacing: 0.3px;
            text-transform: uppercase;
            transform-style: preserve-3d;
        }

        /* Prevent buttons from rotating with card flip */
        .card.flipped .card-front .card-control-btn,
        .card.flipped .card-front .nav-btn-inline,
        .card.flipped .card-front .card-action-small {
            transform: rotateY(-180deg);
            pointer-events: auto;
        }

        /* Ensure buttons are clickable */
        .card-control-btn,
        .nav-btn-inline,
        .card-action-small {
            pointer-events: auto;
            position: relative;
        }

        .card-control-btn:hover {
            background: #2a2a2a;
            border-color: #444444;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .card-control-btn:active {
            transform: scale(0.95);
            background: #0f0f0f;
        }

        .card-action-small {
            padding: 10px 34px;
            background: var(--bg-card);
            color: var(--text-muted);
            border: 1.5px solid #333333;
            border-radius: 6px;
            font-size: 17px;
            font-weight: 700;
            font-family: var(--font-emphasis);
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 128px;
            height: 46px;
            letter-spacing: 0.3px;
            text-transform: uppercase;
            transform-style: preserve-3d;
            white-space: nowrap;
            overflow: hidden;
        }

        .card-action-small:hover {
            background: #2a2a2a;
            border-color: #444444;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .card-action-small:active {
            transform: scale(0.95);
            background: #0f0f0f;
        }

        .card-details {
            font-family: var(--font-reading);
            font-size: 18px;
            line-height: 1.8;
            text-align: center;
            width: 100%;
            max-width: 100%;
            overflow-wrap: break-word;
            word-wrap: break-word;
            color: var(--text-primary);
        }

        @media (max-width: 767px) {
            .card-details {
                font-size: 16px;
            }
        }

        .card-details strong {
            color: var(--accent-secondary);
        }

        .sentence {
            margin-top: 15px;
            padding: 15px;
            background: rgba(var(--accent-primary-rgb), 0.08);
            border: 1px solid var(--accent-primary);
            border-left: 3px solid var(--accent-primary);
            border-radius: 8px;
            font-family: var(--font-reading);
            font-style: italic;
            font-size: 22px;
            overflow-wrap: break-word;
            word-wrap: break-word;
            text-align: center;
            color: #ffffff;
        }

        @media (max-width: 767px) {
            .sentence {
                font-size: 20px;
                padding: 12px;
            }
        }

        .translation {
            margin-top: 8px;
            color: var(--accent-secondary);
            font-size: 16px;
            font-weight: 500;
        }

        .links-section {
            margin-top: auto;
            padding-top: 15px;
            border-top: 1px solid var(--border-color);
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .link-btn {
            display: inline-block;
            padding: 8px 16px;
            background: var(--bg-tertiary);
            color: var(--accent-secondary);
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
            border: 1px solid var(--border-color);
            transition: all 0.3s;
        }

        .link-btn:hover {
            background: var(--accent-secondary);
            color: var(--bg-primary);
            border-color: var(--accent-secondary);
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            background: var(--bg-card);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }

        .nav-btn {
            padding: 12px 24px;
            background: var(--accent-primary);
            color: var(--bg-primary);
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .nav-btn:hover {
            box-shadow: 0 0 20px var(--glow-orange);
        }

        .nav-btn:disabled {
            background: var(--bg-tertiary);
            color: var(--text-muted);
            cursor: not-allowed;
        }

        #correctBtn:hover:not(:disabled) {
            box-shadow: 0 0 20px var(--glow-green);
        }

        #incorrectBtn:hover:not(:disabled) {
            box-shadow: 0 0 20px rgba(255, 82, 82, 0.5);
        }

        .nav-btn-inline {
            padding: 10px 14px;
            background: var(--bg-tertiary);
            color: var(--accent-secondary);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            font-size: 24px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 10;
            transform-style: preserve-3d;
        }

        .nav-btn-inline:hover {
            background: var(--accent-secondary);
            color: var(--bg-primary);
            border-color: var(--accent-secondary);
        }

        .nav-btn-inline:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .progress {
            text-align: center;
            font-weight: 600;
            color: var(--accent-secondary);
        }

        .action-btn {
            padding: 0;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 43px;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.15s ease-out, filter 0.15s ease-out;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        .action-btn:hover {
            transform: scale(1.1);
        }

        .action-btn:active {
            transform: scale(0.75);
            filter: brightness(0.8);
        }

        /* For touch devices - maintain pressed state while held */
        @media (hover: none) {
            .action-btn:active {
                transform: scale(0.7);
            }
        }

        .control-action-btn {
            padding: 10px 20px;
            background: #1a1a1a;
            color: var(--text-primary);
            border: 1.5px solid #333333;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 700;
            font-family: var(--font-emphasis);
            cursor: pointer;
            transition: all 0.3s;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        .control-action-btn:hover {
            background: #2a2a2a;
            border-color: #444444;
            box-shadow: 0 0 12px rgba(0, 0, 0, 0.5);
        }

        .control-action-btn:active {
            transform: scale(0.95);
            background: #0f0f0f;
        }

        .quiz-container {
            background: var(--bg-card);
            padding: 30px;
            border-radius: 16px;
            border: 1px solid var(--border-color);
            margin-bottom: 20px;
        }

        .quiz-question {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 25px;
            color: var(--accent-primary);
            text-align: center;
        }

        .quiz-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .quiz-option {
            padding: 15px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 16px;
            color: var(--text-primary);
        }

        .quiz-option:hover {
            background: var(--bg-card-hover);
            border-color: var(--accent-blue);
        }

        .quiz-option.correct {
            background: rgba(0, 212, 170, 0.15);
            border-color: var(--accent-green);
        }

        .quiz-option.incorrect {
            background: rgba(255, 82, 82, 0.15);
            border-color: var(--error);
        }

        .quiz-feedback {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-weight: 600;
        }

        .quiz-feedback.correct {
            background: rgba(0, 212, 170, 0.15);
            color: var(--accent-green);
        }

        .quiz-feedback.incorrect {
            background: rgba(255, 82, 82, 0.15);
            color: var(--error);
        }

        .type-container {
            background: var(--bg-card);
            padding: 30px;
            border-radius: 16px;
            border: 1px solid var(--border-color);
            margin-bottom: 20px;
        }

        .type-prompt {
            font-size: 20px;
            margin-bottom: 20px;
            color: var(--accent-primary);
            text-align: center;
        }

        .type-input {
            width: 100%;
            padding: 15px;
            font-size: 18px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 15px;
            color: var(--text-primary);
        }

        .type-input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .check-btn {
            width: 100%;
            padding: 15px;
            background: var(--accent-primary);
            color: var(--bg-primary);
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }

        .stats {
            background: var(--bg-card);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            margin-bottom: 20px;
        }

        .stats h3 {
            color: var(--accent-primary);
            margin-bottom: 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-secondary);
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .file-upload {
            background: transparent;
            padding: 10px;
            border-radius: 12px;
            margin-bottom: 20px;
            text-align: center;
        }

        .file-input {
            display: none;
        }

        .upload-btn {
            padding: 12px 24px;
            background: var(--accent-primary);
            color: var(--bg-primary);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
        }

        .hidden {
            display: none !important;
        }

        #appContent {
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
        }

        /* Setup Steps */
        .setup-step {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
        }

        .step-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 15px;
        }

        .step-number {
            font-family: var(--font-data);
            width: 28px;
            height: 28px;
            background: var(--accent-secondary);
            color: var(--bg-primary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 14px;
        }

        .step-title {
            font-family: var(--font-emphasis);
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .level-selector {
            display: flex;
            flex-wrap: nowrap;
            gap: 0;
            justify-content: flex-start;
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 4px;
            overflow-x: auto;
            overflow-y: hidden;
            scrollbar-width: thin;
            scrollbar-color: var(--border-color) transparent;
        }

        .level-selector::-webkit-scrollbar {
            height: 6px;
        }

        .level-selector::-webkit-scrollbar-track {
            background: transparent;
        }

        .level-selector::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        .level-btn {
            flex: 0 0 auto;
            min-width: 60px;
            padding: 10px 14px;
            background: transparent;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            color: var(--text-muted);
        }

        .level-btn:hover {
            background: rgba(255, 107, 53, 0.1);
            color: var(--text-primary);
        }

        .level-btn.selected {
            background: var(--bg-card);
            color: var(--accent-primary);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .range-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .range-btn-new {
            font-family: var(--font-data);
            padding: 10px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s;
            color: var(--accent-blue);
            min-width: 81px;
        }

        .range-btn-new:hover {
            background: var(--accent-blue);
            color: var(--bg-primary);
            border-color: var(--accent-blue);
            box-shadow: 0 0 15px var(--glow-blue);
            transform: translateY(-2px);
        }

        .range-btn-new:active {
            transform: scale(0.95);
        }

        .range-btn-new.disabled,
        .range-btn-new:disabled {
            background: var(--bg-secondary);
            color: var(--text-muted);
            border-color: var(--border-color);
            cursor: not-allowed;
            opacity: 0.35;
            pointer-events: none;
        }

        .range-btn-new.disabled:hover,
        .range-btn-new:disabled:hover {
            background: var(--bg-secondary);
            color: var(--text-muted);
            border-color: var(--border-color);
            box-shadow: none;
            transform: none;
            cursor: not-allowed;
            pointer-events: none;
        }

        .range-btn-new.disabled:active,
        .range-btn-new:disabled:active {
            transform: none;
            pointer-events: none;
        }

        .range-btn {
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            color: var(--text-secondary);
        }

        .range-btn:hover {
            background: var(--bg-card-hover);
            border-color: var(--accent-primary);
        }

        .range-btn.selected {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-color: var(--accent-primary);
        }

        .language-tabs {
            display: flex;
            gap: 0;
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 4px;
            overflow-x: auto;
            overflow-y: hidden;
            scrollbar-width: thin;
            scrollbar-color: var(--border-color) transparent;
        }

        .language-tabs::-webkit-scrollbar {
            height: 6px;
        }

        .language-tabs::-webkit-scrollbar-track {
            background: transparent;
        }

        .language-tabs::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        .lang-tab {
            flex: 0 0 auto;
            min-width: 60px;
            padding: 10px 14px;
            background: transparent;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            color: var(--text-muted);
        }

        .lang-tab.active {
            background: var(--bg-card);
            color: var(--accent-primary);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .lang-tab.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            position: relative;
        }

        .lang-tab.disabled:hover {
            background: transparent;
            color: var(--text-muted);
        }

        .cefr-card {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.3s;
        }

        .cefr-card:hover {
            transform: translateY(-2px);
            border-color: var(--accent-primary);
            box-shadow: 0 4px 20px rgba(255, 107, 53, 0.15);
        }

        .cefr-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .cefr-level {
            font-family: var(--font-emphasis);
            font-size: 24px;
            font-weight: 700;
            color: var(--accent-primary);
        }

        .cefr-description {
            font-size: 14px;
            color: var(--text-muted);
        }

        .cefr-stats {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            font-size: 14px;
            color: var(--text-secondary);
        }

        .cefr-stats strong {
            color: var(--accent-secondary);
        }

        .cefr-ranges {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--border-color);
            display: none;
        }

        .cefr-card.expanded .cefr-ranges {
            display: block;
        }

        .cefr-ranges-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .cefr-range-btn {
            font-family: var(--font-data);
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s;
            color: var(--text-secondary);
        }

        .cefr-range-btn:hover {
            background: var(--bg-card-hover);
            border-color: var(--accent-blue);
        }

        .cefr-range-btn.selected {
            background: var(--accent-blue);
            color: var(--bg-primary);
            border-color: var(--accent-blue);
            box-shadow: 0 0 10px var(--glow-blue);
        }

        .preset-size-btn {
            padding: 10px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            color: var(--text-secondary);
        }

        .preset-size-btn:hover {
            background: var(--bg-card-hover);
            border-color: var(--accent-primary);
        }

        .preset-size-btn.selected {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-color: var(--accent-primary);
        }

        .group-size-selector {
            display: flex;
            gap: 0;
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 4px;
            overflow-x: auto;
            overflow-y: hidden;
            scrollbar-width: thin;
            scrollbar-color: var(--border-color) transparent;
            justify-content: center;
        }

        .group-size-selector::-webkit-scrollbar {
            height: 6px;
        }

        .group-size-selector::-webkit-scrollbar-track {
            background: transparent;
        }

        .group-size-selector::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        .group-size-btn {
            font-family: var(--font-data);
            flex: 0 0 auto;
            padding: 10px 12px;
            background: transparent;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            min-width: 46px;
            color: var(--text-muted);
        }

        .group-size-btn:hover {
            background: rgba(255, 107, 53, 0.1);
            color: var(--text-primary);
        }

        .group-size-btn.selected {
            background: var(--bg-card);
            color: var(--accent-primary);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .step-row {
            display: flex;
            gap: 15px;
            width: 100%;
        }

        .step-half {
            flex: 1;
            min-width: 0;
            max-width: 90%;
        }

        .step-half:first-child {
            flex: 0.9;
        }

        .step-half:last-child {
            flex: 1.1;
        }

        .step-half .step-header {
            margin-bottom: 10px;
        }

        .lemma-toggle-btn {
            font-family: var(--font-data);
            flex: 1;
            padding: 10px 10px;
            background: transparent;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            min-width: 38px;
            color: var(--text-muted);
        }

        .lemma-toggle-btn:hover {
            background: rgba(255, 107, 53, 0.1);
            color: var(--text-primary);
        }

        .lemma-toggle-btn.selected {
            background: var(--bg-card);
            color: var(--accent-primary);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .step-help-btn {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--accent-secondary);
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            margin-left: 4px;
            flex-shrink: 0;
        }

        .step-help-btn:hover {
            background: var(--accent-secondary);
            color: var(--bg-primary);
            border-color: var(--accent-secondary);
        }

        .step-info-tooltip {
            display: none;
            position: absolute;
            top: calc(100% + 8px);
            left: 0;
            right: 0;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            font-size: 13px;
            line-height: 1.5;
            color: var(--text-secondary);
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .step-info-tooltip.visible {
            display: block;
        }

        .step-info-tooltip p {
            margin: 0 0 8px 0;
        }

        .step-info-tooltip p:last-child {
            margin-bottom: 0;
        }

        .step-info-tooltip strong {
            color: var(--accent-primary);
        }

        .step-header-with-help {
            position: relative;
            display: flex;
            align-items: center;
        }

        .cefr-actions {
            display: none;
            margin-top: 15px;
            gap: 10px;
            justify-content: space-between;
        }

        .cefr-card.expanded .cefr-actions {
            display: flex;
        }

        .start-level-btn {
            flex: 1;
            padding: 12px;
            background: var(--accent-green);
            color: var(--bg-primary);
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .start-level-btn:hover {
            box-shadow: 0 0 20px var(--glow-green);
        }

        .start-level-btn:disabled {
            background: var(--bg-tertiary);
            color: var(--text-muted);
            cursor: not-allowed;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal:not(.hidden) {
            display: flex;
        }

        .modal-content {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            border: 1px solid var(--border-color);
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }

        .modal-header h3 {
            font-family: var(--font-emphasis);
            color: var(--accent-primary);
            margin: 0;
            font-size: 24px;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: var(--text-muted);
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            color: var(--accent-primary);
        }

        .stats-body {
            margin-top: 15px;
        }

        .tap-hint {
            text-align: center;
            color: var(--text-muted);
            font-size: 14px;
            margin-top: 10px;
            font-style: italic;
        }

        .flip-circle {
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 60px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
        }

        .flip-circle:hover {
            border-color: rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.02);
        }

        .flip-circle:active {
            transform: scale(0.98);
        }

        .flip-back-area {
            display: inline-block;
            padding: 20px 40px;
            border: 2px solid rgba(255, 255, 255, 0);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .flip-back-area:hover {
            border-color: rgba(255, 255, 255, 0.15);
            background: rgba(255, 255, 255, 0.02);
        }

        .flip-back-area:active {
            transform: scale(0.98);
        }

        #flipBtn {
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        #flipBtn:focus {
            outline: none !important;
            box-shadow: none !important;
        }

        #flipBtn:active {
            opacity: 0.8;
        }

        /* Meaning boxes styles */
        .meanings-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            margin: 15px 0;
            width: 100%;
        }

        .meaning-box {
            padding: 10px 16px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            min-width: 80px;
            position: relative;
        }

        .meaning-box:hover {
            transform: translateY(-2px);
            border-color: var(--accent-blue);
        }

        .meaning-box.selected {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            transform: scale(1.05);
        }

        .meaning-box.selected .meaning-text {
            color: var(--bg-primary);
        }

        .meaning-box.selected .meaning-pos {
            color: var(--bg-primary);
            opacity: 0.8;
        }

        .meaning-text {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .meaning-pos {
            font-size: 11px;
            color: var(--accent-secondary);
            margin-top: 4px;
            font-family: var(--font-data);
            text-transform: uppercase;
        }

        .meaning-percent {
            position: absolute;
            top: -8px;
            right: -8px;
            background: var(--accent-secondary);
            color: var(--bg-primary);
            font-size: 10px;
            font-weight: 700;
            padding: 2px 6px;
            border-radius: 10px;
            font-family: var(--font-data);
        }

        /* Deck Complete Modal Styles */
        .deck-complete-body {
            padding: 10px 0;
        }

        .deck-complete-stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 15px;
        }

        .deck-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px 25px;
            border-radius: 12px;
            min-width: 90px;
        }

        .deck-stat.correct-stat {
            background: rgba(0, 212, 170, 0.15);
            color: var(--accent-green);
            border: 1px solid var(--accent-green);
        }

        .deck-stat.incorrect-stat {
            background: rgba(255, 82, 82, 0.15);
            color: var(--error);
            border: 1px solid var(--error);
        }

        .deck-stat-emoji {
            font-size: 28px;
            margin-bottom: 5px;
        }

        .deck-stat span:last-child {
            font-size: 24px;
            font-weight: bold;
        }

        .deck-complete-actions {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
        }

        .deck-complete-btn {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 16px 12px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            gap: 8px;
        }

        .deck-complete-btn .btn-icon {
            font-size: 24px;
        }

        .deck-complete-btn.restart-btn {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }

        .deck-complete-btn.restart-btn:hover {
            background: var(--bg-card-hover);
            border-color: var(--accent-secondary);
        }

        .deck-complete-btn.continue-btn {
            background: var(--accent-blue);
            color: var(--bg-primary);
        }

        .deck-complete-btn.continue-btn:hover {
            box-shadow: 0 0 20px var(--glow-blue);
        }

        .deck-complete-btn.continue-btn:disabled {
            background: var(--bg-tertiary);
            color: var(--text-muted);
            cursor: not-allowed;
        }

        .deck-complete-btn.mark-complete-btn {
            width: 100%;
            background: var(--accent-green);
            color: var(--bg-primary);
            flex-direction: row;
            gap: 10px;
        }

        .deck-complete-btn.mark-complete-btn:hover {
            box-shadow: 0 0 20px var(--glow-green);
        }

        @media (max-width: 767px) {
            .card {
                height: calc(100vh - 180px);
                min-height: 460px;
                max-height: 633px;
            }

            .card-word {
                font-size: 48px;
            }

            .action-btn {
                font-size: 32px;
            }

        }
    </style>
</head>
<body>
    <div class="container">
        <div class="file-upload" id="setupPanel">
            <!-- Step 1: Language Selection -->
            <div id="step1" class="setup-step">
                <div class="step-header step-header-with-help">
                    <span class="step-number">1</span>
                    <span class="step-title">Choose Language</span>
                    <button class="step-help-btn" data-tooltip="step1Tooltip" title="Help">?</button>
                    <div id="step1Tooltip" class="step-info-tooltip">
                        <p><strong>How to Study:</strong></p>
                        <p><strong>Tap card</strong> to flip and see translation</p>
                        <p><strong>Swipe right</strong> if you know the word âœ“</p>
                        <p><strong>Swipe left</strong> if you don't know it âœ—</p>
                        <p><strong>Words with multiple meanings:</strong> Swipe up/down on the back of the card to cycle through different definitions and their example sentences</p>
                        <p><strong>Arrow buttons</strong> to navigate cards manually</p>
                        <p><strong>Language button</strong> (top-left) switches direction between Target â†’ English and English â†’ Target</p>
                        <p><strong>At the end of each set</strong>, you'll see your accuracy and can review incorrect cards or continue to the next set</p>
                        <hr style="margin: 15px 0; border: none; border-top: 1px solid var(--border-color);">
                        <p><strong>Why Frequency Matters:</strong></p>
                        <p>Language follows a power law distribution: a small number of words account for the vast majority of everyday speech. Studies show that just 1,000 of the most common words make up approximately 80% of spoken language, while the top 3,000 words cover around 95% of typical conversations.</p>
                        <p>This app uses word frequency data derived from movie and TV subtitles, which represent natural, authentic language as it's actually spoken. By learning words ranked by how often they appear in real dialogue, you build practical fluency more efficiently than memorizing random vocabulary lists.</p>
                    </div>
                </div>
                <div class="language-tabs" id="languageTabs">
                    <!-- Language tabs will be dynamically generated -->
                </div>
            </div>

            <!-- Step 2: Level Selection -->
            <div id="step2" class="setup-step">
                <div class="step-header step-header-with-help">
                    <span class="step-number">2</span>
                    <span class="step-title">Choose Level</span>
                    <button class="step-help-btn" data-tooltip="step2Tooltip" title="Help">?</button>
                    <div id="step2Tooltip" class="step-info-tooltip">
                        <p><strong>CEFR Levels</strong> indicate proficiency from beginner (A1) to proficient (C2).</p>
                        <p>Words are ranked by frequency. Lower levels cover the most common words needed for basic comprehension.</p>
                    </div>
                </div>
                <div id="levelSelector" class="level-selector"></div>
            </div>

            <!-- Step 3: Cards per Set and 1 Card per Lemma (side by side) -->
            <div id="step3" class="setup-step" style="display: none;">
                <div class="step-row">
                    <div class="step-half">
                        <div class="step-header step-header-with-help">
                            <span class="step-number">3</span>
                            <span class="step-title">Cards per Set</span>
                            <button class="step-help-btn" data-tooltip="step3Tooltip" title="Help">?</button>
                            <div id="step3Tooltip" class="step-info-tooltip">
                                <p>Choose how many flashcards to study in each session.</p>
                                <p>Smaller sets (25) are good for quick review. Larger sets (50) for more intensive study.</p>
                            </div>
                        </div>
                        <div id="groupSizeSelector" class="group-size-selector">
                            <button class="group-size-btn selected" data-size="25">25</button>
                            <button class="group-size-btn" data-size="50">50</button>
                        </div>
                    </div>
                    <div class="step-half" id="lemmaToggleContainer" style="display: none;">
                        <div class="step-header step-header-with-help">
                            <span class="step-number">4</span>
                            <span class="step-title">Cards per Lemma</span>
                            <button class="step-help-btn" data-tooltip="step4Tooltip" title="Help">?</button>
                            <div id="step4Tooltip" class="step-info-tooltip">
                                <p><strong>Lemma</strong> = the base/dictionary form of a word.</p>
                                <p><strong>1</strong> = See only one card per lemma, skipping conjugations and declensions (e.g., "run" but not "runs", "ran", "running"). This reduces redundancy and focuses on learning root vocabulary.</p>
                                <p><strong>1+</strong> = See all forms including conjugations and declensions, which helps with recognition of different word forms in context.</p>
                            </div>
                        </div>
                        <div id="lemmaToggleSelector" class="group-size-selector">
                            <button class="lemma-toggle-btn" data-lemma="off">1+</button>
                            <button class="lemma-toggle-btn selected" data-lemma="on">1</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Step 5: Range Selection -->
            <div id="step4" class="setup-step" style="display: none;">
                <div class="step-header step-header-with-help">
                    <span class="step-number" id="rangeStepNumber">5</span>
                    <span class="step-title">Choose Set</span>
                    <button class="step-help-btn" data-tooltip="step5Tooltip" title="Help">?</button>
                    <div id="step5Tooltip" class="step-info-tooltip">
                        <p>Each set contains words ranked by frequency (e.g., 1-25 = most common words).</p>
                        <p><strong>Example sentences</strong> are designed to use words from nearby ranks (within ~20 positions), so practicing set 1-25 means sentences mostly use words from that same group.</p>
                    </div>
                </div>
                <div id="rangeSelector" class="range-selector"></div>
            </div>

            <div id="loadingMessage" style="margin-top: 20px; color: var(--accent-green); display: none; text-align: center; font-weight: 600;"></div>
        </div>

        <div id="appContent" class="hidden">
            <!-- Flashcard Mode -->
            <div id="flashcardMode">
                <div class="card-container">
                    <div class="swipe-indicator incorrect" id="incorrectIndicator">âœ—</div>
                    <div class="swipe-indicator correct" id="correctIndicator">âœ“</div>
                    <div class="card" id="flashcard" data-rank="">
                        <div class="card-face card-front">
                            <!-- Reverse button on left edge -->
                            <div style="position: absolute; top: 20px; left: 20px; z-index: 5; pointer-events: none;">
                                <button class="card-action-small" id="reverseLangBtn" title="Reverse language direction" style="pointer-events: auto;">REVERSE</button>
                            </div>
                            <!-- Shuffle button on right edge -->
                            <div style="position: absolute; top: 20px; right: 20px; z-index: 5; pointer-events: none;">
                                <button class="card-action-small" id="shuffleBtnTop" title="Shuffle" style="pointer-events: auto;">
                                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                        <polyline points="16 3 21 3 21 8"></polyline>
                                        <line x1="4" y1="20" x2="21" y2="3"></line>
                                        <polyline points="21 16 21 21 16 21"></polyline>
                                        <line x1="15" y1="15" x2="21" y2="21"></line>
                                        <line x1="4" y1="4" x2="9" y2="9"></line>
                                    </svg>
                                </button>
                            </div>
                            <button id="flipBtn" style="background: transparent; border: none; cursor: pointer; outline: none; padding: 60px; border-radius: 50%; width: 100%; z-index: 1;">
                                <div class="card-word" id="frontWord"></div>
                                <div class="card-lemma" id="frontLemma"></div>
                                <div class="card-ranking" id="frontRanking"></div>
                            </button>
                            <!-- Left/right nav buttons beside the word -->
                            <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; position: absolute; top: 50%; transform: translateY(-50%); left: 0; padding: 0 20px; z-index: 5; pointer-events: none;">
                                <button class="nav-btn-inline" id="prevBtnFront" style="pointer-events: auto;">â†</button>
                                <button class="nav-btn-inline" id="nextBtnFront" style="pointer-events: auto;">â†’</button>
                            </div>
                            <!-- Back button on bottom left -->
                            <div style="position: absolute; bottom: 20px; left: 20px; z-index: 5; pointer-events: none;">
                                <button class="card-action-small" id="backBtnSmall" title="Back to menu" style="pointer-events: auto;">â†©</button>
                            </div>
                            <!-- Stats button on bottom right -->
                            <div style="position: absolute; bottom: 20px; right: 20px; z-index: 5; pointer-events: none;">
                                <button class="card-action-small" id="statsBtnSmall" title="View stats" style="pointer-events: auto;">STATS</button>
                            </div>
                        </div>
                        <div class="card-face card-back">
                            <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; position: absolute; top: 20px; left: 0; padding: 0 20px; pointer-events: none;">
                                <div style="display: flex; gap: 10px; align-items: center; pointer-events: auto;">
                                    <button class="nav-btn-inline" id="prevBtnBack">â†</button>
                                    <button class="nav-btn-inline desktop-answer-btn" id="incorrectBtnTop" title="Mark as incorrect" style="display: none; background: var(--error); color: white; border-color: var(--error);">âœ—</button>
                                </div>
                                <div style="display: flex; gap: 10px; align-items: center; pointer-events: auto;">
                                    <button class="nav-btn-inline desktop-answer-btn" id="correctBtnTop" title="Mark as correct" style="display: none; background: var(--success); color: white; border-color: var(--success);">âœ“</button>
                                    <button class="nav-btn-inline" id="nextBtnBack">â†’</button>
                                </div>
                            </div>
                            <div class="card-details" id="backContent"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Deck Complete Modal -->
    <div id="deckCompleteModal" class="modal hidden">
        <div class="modal-content" style="max-width: 350px;">
            <div class="modal-header" style="border-bottom: none; padding-bottom: 0;">
                <h3 style="width: 100%; text-align: center;">Deck Complete!</h3>
            </div>
            <div class="deck-complete-body">
                <div class="deck-complete-stats">
                    <div class="deck-stat correct-stat">
                        <span class="deck-stat-emoji">âœ“</span>
                        <span id="completeCorrect">0</span>
                    </div>
                    <div class="deck-stat incorrect-stat">
                        <span class="deck-stat-emoji">âœ—</span>
                        <span id="completeIncorrect">0</span>
                    </div>
                </div>
                <div id="completeAccuracy" style="text-align: center; font-size: 18px; color: var(--text-secondary); margin-bottom: 20px;"></div>
                <div id="completeMessage" style="text-align: center; color: var(--text-secondary); margin-bottom: 20px;"></div>
                <div class="deck-complete-actions">
                    <button class="deck-complete-btn restart-btn" id="restartAllBtn">
                        <span class="btn-icon">ðŸ”„</span>
                        <span>Restart All</span>
                    </button>
                    <button class="deck-complete-btn continue-btn" id="continueIncorrectBtn">
                        <span class="btn-icon">ðŸ“</span>
                        <span>Review Mistakes</span>
                    </button>
                </div>
                <button class="deck-complete-btn mark-complete-btn" id="markCompleteBtn">
                    <span class="btn-icon">âœ…</span>
                    <span>Mark Complete & Exit</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Stats Modal -->
    <div id="statsModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Your Progress</h3>
                <button class="modal-close" id="closeStatsModal">âœ•</button>
            </div>
            <div class="stats-body">
                <div class="stat-row">
                    <span>Cards Studied:</span>
                    <span id="cardsStudied">0</span>
                </div>
                <div class="stat-row">
                    <span>Total Cards:</span>
                    <span id="totalCardsStats">0</span>
                </div>
                <div class="stat-row">
                    <span>Progress:</span>
                    <span id="progressPercent">0%</span>
                </div>
                <div class="stat-row">
                    <span style="color: var(--accent-green);">âœ“ Correct:</span>
                    <span id="correctCount" style="color: var(--accent-green);">0</span>
                </div>
                <div class="stat-row">
                    <span style="color: var(--error);">âœ— Incorrect:</span>
                    <span id="incorrectCount" style="color: var(--error);">0</span>
                </div>
                <div class="stat-row">
                    <span>Accuracy:</span>
                    <span id="accuracyPercent">-</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Register service worker for PWA functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('service-worker.js')
                    .then(registration => console.log('SW registered'))
                    .catch(err => console.log('SW registration failed'));
            });
        }

        let flashcards = [];
        let currentIndex = 0;
        let currentSentenceIndex = 0; // Track which example sentence is being shown
        let currentMeaningIndex = 0; // Track which meaning is selected
        let stats = {
            studied: new Set(),
            correct: 0,
            incorrect: 0,
            total: 0,
            cardStats: {} // Track individual card performance: cardIndex -> {correct: count, incorrect: count}
        };
        let currentMode = 'flashcards';
        let config = null;
        let selectedLanguage = 'spanish';
        let selectedLevel = null;
        let selectedRanges = [];
        let isFlipped = false;
        let groupSize = 25; // Default group size
        let useLemmaMode = true; // Whether to use 1 card per lemma mode
        let isAppInitialized = false; // Track if event listeners have been set up
        let cefrLevelsConfig = null; // CEFR levels configuration for lemma/standard modes

        // Load configuration
        async function loadConfig() {
            try {
                const [configResponse, cefrResponse] = await Promise.all([
                    fetch('config.json'),
                    fetch('cefr_levels.json')
                ]);
                config = await configResponse.json();
                cefrLevelsConfig = await cefrResponse.json();
            } catch (error) {
                console.error('Failed to load config:', error);
                alert('Failed to load configuration. Please refresh the page.');
            }
        }

        // Get the appropriate CEFR levels based on language and lemma mode
        function getCefrLevels(language) {
            if (cefrLevelsConfig && cefrLevelsConfig[language]) {
                return useLemmaMode ? cefrLevelsConfig[language].lemmaMode : cefrLevelsConfig[language].standard;
            }
            // Fallback to config.json levels
            return config.languages[language].cefrLevels;
        }

        // Setup tooltip handlers (needs to run early, before any set is picked)
        function setupTooltipHandlers() {
            // Step help tooltip handlers
            document.querySelectorAll('.step-help-btn').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const tooltipId = this.dataset.tooltip;
                    const tooltip = document.getElementById(tooltipId);

                    // Close all other tooltips first
                    document.querySelectorAll('.step-info-tooltip').forEach(t => {
                        if (t.id !== tooltipId) {
                            t.classList.remove('visible');
                        }
                    });

                    // Toggle this tooltip
                    tooltip.classList.toggle('visible');
                });
            });

            // Close tooltips when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.step-help-btn') && !e.target.closest('.step-info-tooltip')) {
                    document.querySelectorAll('.step-info-tooltip').forEach(t => {
                        t.classList.remove('visible');
                    });
                }
            });
        }

        // Initialize on page load
        loadConfig().then(() => {
            renderLanguageTabs();
            // Set first language with data as default
            const firstLang = Object.keys(config.languages).find(lang => config.languages[lang].hasData !== false) || Object.keys(config.languages)[0];
            selectedLanguage = firstLang;
            applyLanguageColorTheme();
            renderLevelSelector(firstLang);
            setupGroupSizeSelector();
            setupLemmaToggle();
            updateLemmaToggleVisibility();
            setupTooltipHandlers(); // Initialize tooltips early
        });

        function renderLanguageTabs() {
            const tabsContainer = document.getElementById('languageTabs');

            // Define custom language order (Polish before grayed-out French and Russian)
            const languageOrder = ['spanish', 'swedish', 'italian', 'dutch', 'polish', 'french', 'russian'];
            const languages = languageOrder.filter(lang => config.languages[lang]);

            // Map language keys to 2-letter codes
            const langCodeMap = {
                'dutch': 'NL',
                'polish': 'PL',
                'spanish': 'ES',
                'italian': 'IT',
                'french': 'FR',
                'russian': 'RU',
                'swedish': 'SE'
            };

            // Generate language tabs dynamically
            const tabsHTML = languages.map((langKey, index) => {
                const langCode = langCodeMap[langKey] || langKey.substring(0, 2).toUpperCase();
                const langConfig = config.languages[langKey];
                const hasData = langConfig.hasData !== false;
                const activeClass = index === 0 && hasData ? 'active' : '';
                const disabledClass = !hasData ? 'disabled' : '';
                const disabledAttr = !hasData ? 'disabled' : '';
                const title = !hasData ? `${langConfig.name} - Data coming soon` : '';
                return `<button class="lang-tab ${activeClass} ${disabledClass}" data-lang="${langKey}" ${disabledAttr} title="${title}">${langCode}</button>`;
            }).join('');

            tabsContainer.innerHTML = tabsHTML;

            // Setup event listeners for tabs
            setupLanguageTabs();
        }

        function setupLanguageTabs() {
            document.querySelectorAll('.lang-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    // Prevent clicking on disabled tabs
                    if (this.disabled || this.classList.contains('disabled')) {
                        return;
                    }
                    document.querySelectorAll('.lang-tab').forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    selectedLanguage = this.dataset.lang;
                    selectedLevel = null;
                    applyLanguageColorTheme();
                    renderLevelSelector(selectedLanguage);
                    updateLemmaToggleVisibility();
                    // Hide steps 3 and 4
                    document.getElementById('step3').style.display = 'none';
                    document.getElementById('step4').style.display = 'none';
                });
            });
        }

        function renderLevelSelector(language) {
            const container = document.getElementById('levelSelector');
            const cefrLevels = getCefrLevels(language);

            const levelsHTML = cefrLevels.map(level => `
                <button class="level-btn" data-level="${level.level}" title="${level.description}">
                    ${level.level}
                </button>
            `).join('');

            container.innerHTML = levelsHTML;

            // Add click handlers
            document.querySelectorAll('.level-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.level-btn').forEach(b => b.classList.remove('selected'));
                    this.classList.add('selected');
                    selectedLevel = this.dataset.level;
                    // Show steps 3 and 4
                    document.getElementById('step3').style.display = 'block';
                    renderRangeSelector().catch(err => console.error('Error rendering ranges:', err));
                });
            });
        }

        function setupGroupSizeSelector() {
            document.querySelectorAll('.group-size-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.group-size-btn').forEach(b => b.classList.remove('selected'));
                    this.classList.add('selected');
                    groupSize = parseInt(this.dataset.size);
                    // Re-render range selector if a level is selected
                    if (selectedLevel) {
                        renderRangeSelector().catch(err => console.error('Error rendering ranges:', err));
                    }
                });
            });
        }

        function setupLemmaToggle() {
            document.querySelectorAll('.lemma-toggle-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.lemma-toggle-btn').forEach(b => b.classList.remove('selected'));
                    this.classList.add('selected');
                    useLemmaMode = this.dataset.lemma === 'on';
                    // Re-render level selector with new word counts, and re-render range selector if a level is selected
                    renderLevelSelector(selectedLanguage);
                    // Re-select the current level if one was selected
                    if (selectedLevel) {
                        const levelBtn = document.querySelector(`.level-btn[data-level="${selectedLevel}"]`);
                        if (levelBtn) {
                            levelBtn.classList.add('selected');
                        }
                        renderRangeSelector().catch(err => console.error('Error rendering ranges:', err));
                    }
                });
            });
        }

        function updateLemmaToggleVisibility() {
            const langConfig = config.languages[selectedLanguage];
            const lemmaContainer = document.getElementById('lemmaToggleContainer');
            const rangeStepNumber = document.getElementById('rangeStepNumber');

            if (langConfig && langConfig.lemmaDeduplicatedPath) {
                lemmaContainer.style.display = 'block';
                rangeStepNumber.textContent = '5';
            } else {
                lemmaContainer.style.display = 'none';
                rangeStepNumber.textContent = '4';
                // Reset lemma mode when hiding
                useLemmaMode = true;
                document.querySelectorAll('.lemma-toggle-btn').forEach(b => b.classList.remove('selected'));
                document.querySelector('.lemma-toggle-btn[data-lemma="on"]').classList.add('selected');
            }
        }

        function applyLanguageColorTheme() {
            const langConfig = config.languages[selectedLanguage];
            if (langConfig && langConfig.colorTheme) {
                const root = document.documentElement;
                root.style.setProperty('--accent-primary', langConfig.colorTheme.primary);
                root.style.setProperty('--accent-secondary', langConfig.colorTheme.secondary);

                // Convert hex to RGB for opacity usage
                const hexToRgb = (hex) => {
                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : '0, 0, 0';
                };

                root.style.setProperty('--accent-primary-rgb', hexToRgb(langConfig.colorTheme.primary));
                root.style.setProperty('--accent-secondary-rgb', hexToRgb(langConfig.colorTheme.secondary));
            }
        }

        async function renderRangeSelector() {
            const langConfig = config.languages[selectedLanguage];
            const cefrLevels = getCefrLevels(selectedLanguage);
            const level = cefrLevels.find(l => l.level === selectedLevel);
            const container = document.getElementById('rangeSelector');

            if (!level) return;

            // Parse the wordCount range for this level (e.g., "1-800" -> 1, 800)
            const [minWord, maxWord] = level.wordCount.split('-').map(Number);

            // Always use the regular data path
            const dataPath = langConfig.dataPath;

            // Load the vocabulary data to check which ranks exist
            let vocabularyData = [];
            try {
                if (dataPath) {
                    const response = await fetch(dataPath);
                    if (response.ok) {
                        vocabularyData = await response.json();
                    }
                }
            } catch (error) {
                console.error('Failed to load vocabulary data:', error);
            }

            // Filter to non-blank entries and exclude duplicates
            let filteredVocab = vocabularyData.filter(item =>
                item.word && item.word.trim() !== '' && !item.duplicate && item.meanings && item.meanings.length > 0
            );

            // If in lemma mode, keep only first occurrence of each lemma from entire dataset
            if (useLemmaMode) {
                const seenLemmas = new Set();
                filteredVocab = filteredVocab.filter(item => {
                    const lemma = item.lemma || item.word;
                    if (seenLemmas.has(lemma)) {
                        return false;
                    }
                    seenLemmas.add(lemma);
                    return true;
                });
            }

            // Re-rank ALL filtered data based on position (starting from 1)
            filteredVocab.forEach((item, index) => {
                item.rank = index + 1;
            });

            // Now filter to only items within the level's range
            filteredVocab = filteredVocab.filter(item =>
                item.rank >= minWord && item.rank < maxWord
            );

            // Create a Set of all available ranks for fast lookup
            const availableRanks = new Set(filteredVocab.map(item => item.rank));

            // Generate ALL possible range buttons based on groupSize across the full span
            const ranges = [];
            for (let i = minWord; i < maxWord; i += groupSize) {
                const rangeEnd = Math.min(i + groupSize, maxWord);

                // Check if ANY rank in this range has data
                let hasData = false;
                for (let rank = i; rank < rangeEnd; rank++) {
                    if (availableRanks.has(rank)) {
                        hasData = true;
                        break;
                    }
                }

                ranges.push({
                    range: `${i}-${rangeEnd}`,
                    available: hasData
                });
            }

            // Generate HTML with disabled state for unavailable ranges
            const rangesHTML = ranges.map(r => {
                const disabledAttr = !r.available ? 'disabled' : '';
                const disabledClass = !r.available ? 'disabled' : '';
                return `
                    <button class="range-btn-new ${disabledClass}"
                            data-range="${r.range}"
                            ${disabledAttr}
                            title="${r.available ? 'Load ' + r.range : 'Greyed out because no vocabulary data exists for this range yet'}">
                        ${r.range}
                    </button>
                `;
            }).join('');

            // Add "Next Level" button at the end
            const currentLevelIndex = cefrLevels.findIndex(l => l.level === selectedLevel);
            const nextLevel = currentLevelIndex < cefrLevels.length - 1 ? cefrLevels[currentLevelIndex + 1] : null;

            let nextLevelHTML = '';
            if (nextLevel) {
                nextLevelHTML = `
                    <button class="range-btn-new next-level-btn"
                            data-next-level="${nextLevel.level}"
                            title="Go to ${nextLevel.level}">
                        Next Level
                    </button>
                `;
            } else {
                // At the last level, show placeholder box
                nextLevelHTML = `
                    <button class="range-btn-new disabled"
                            disabled
                            title="Completed all levels">
                        ${selectedLevel}
                    </button>
                `;
            }

            container.innerHTML = rangesHTML + nextLevelHTML;
            document.getElementById('step4').style.display = 'block';

            // Add click handlers to ALL buttons
            document.querySelectorAll('.range-btn-new').forEach(btn => {
                btn.addEventListener('click', async function(e) {
                    // Handle "Next Level" button
                    if (this.classList.contains('next-level-btn')) {
                        const nextLevelValue = this.dataset.nextLevel;
                        if (nextLevelValue) {
                            selectedLevel = nextLevelValue;
                            // Update level selector UI
                            document.querySelectorAll('.level-btn').forEach(b => b.classList.remove('selected'));
                            const nextLevelBtn = document.querySelector(`.level-btn[data-level="${nextLevelValue}"]`);
                            if (nextLevelBtn) {
                                nextLevelBtn.classList.add('selected');
                            }
                            // Re-render range selector for the new level
                            await renderRangeSelector();
                        }
                        return;
                    }

                    // Prevent disabled buttons from being clicked
                    if (this.disabled || this.classList.contains('disabled')) {
                        e.preventDefault();
                        e.stopPropagation();
                        // Show tooltip message for unavailable datasets
                        const loadingMsg = document.getElementById('loadingMessage');
                        loadingMsg.style.display = 'block';
                        loadingMsg.style.color = 'var(--warning)';
                        loadingMsg.textContent = 'Data not available, pick another set';
                        setTimeout(() => {
                            loadingMsg.style.display = 'none';
                            loadingMsg.style.color = 'var(--accent-green)';
                        }, 2000);
                        return;
                    }

                    const selectedRange = this.dataset.range;

                    document.getElementById('loadingMessage').style.display = 'block';
                    document.getElementById('loadingMessage').textContent = `Loading ${selectedRange}...`;

                    await loadVocabularyData(selectedRange);
                });
            });
        }

        async function loadVocabularyData(rangeString) {
            // Completely clear all previous data and state
            flashcards = [];
            currentIndex = 0;
            currentSentenceIndex = 0;
            currentMeaningIndex = 0;
            isFlipped = false;

            // Reset card flip state
            const flashcardEl = document.getElementById('flashcard');
            if (flashcardEl) {
                flashcardEl.classList.remove('flipped');
            }

            const langConfig = config.languages[selectedLanguage];
            const [rangeStart, rangeEnd] = rangeString.split('-').map(Number);

            // Always use the regular data path
            const dataPath = langConfig.dataPath;

            try {
                // Load the vocabulary JSON
                const response = await fetch(dataPath);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const vocabularyData = await response.json();

                // Filter to non-blank entries and exclude duplicates
                let filteredData = vocabularyData.filter(item =>
                    item.word &&
                    item.word.trim() !== '' &&
                    !item.duplicate &&
                    item.meanings &&
                    item.meanings.length > 0
                );

                // If in lemma mode, keep only first occurrence of each lemma from ENTIRE dataset
                if (useLemmaMode) {
                    const seenLemmas = new Set();
                    filteredData = filteredData.filter(item => {
                        const lemma = item.lemma || item.word;
                        if (seenLemmas.has(lemma)) {
                            return false;
                        }
                        seenLemmas.add(lemma);
                        return true;
                    });
                }

                // Re-rank ALL filtered data based on position
                filteredData.forEach((item, index) => {
                    item.rank = index + 1;
                });

                // NOW filter by the requested range
                filteredData = filteredData.filter(item =>
                    item.rank >= rangeStart && item.rank < rangeEnd
                );

                // Convert to flashcards format
                const exampleTargetField = langConfig.exampleTargetField || 'example_spanish';
                const exampleEnglishField = langConfig.exampleEnglishField || 'example_english';

                for (const item of filteredData) {
                    const meanings = item.meanings.map(m => ({
                        pos: m.pos,
                        meaning: m.translation,
                        percentage: parseFloat(m.frequency),
                        targetSentence: m[exampleTargetField],
                        englishSentence: m[exampleEnglishField]
                    }));

                    // Normalize percentages if they're missing or sum to 0
                    const totalPercentage = meanings.reduce((sum, m) => sum + (m.percentage || 0), 0);
                    if (totalPercentage === 0 || isNaN(totalPercentage)) {
                        // Default to equal distribution
                        const equalPercentage = 1.0 / meanings.length;
                        meanings.forEach(m => {
                            m.percentage = equalPercentage;
                        });
                    } else if (totalPercentage !== 1.0) {
                        // Normalize to sum to 1.0
                        meanings.forEach(m => {
                            m.percentage = (m.percentage || 0) / totalPercentage;
                        });
                    }

                    const card = {
                        targetWord: item.word,
                        lemma: item.lemma || '',
                        rank: item.rank,
                        meanings: meanings,
                        translation: item.meanings[0].translation,
                        targetSentence: item.meanings[0][exampleTargetField],
                        englishSentence: item.meanings[0][exampleEnglishField],
                        links: generateLinks(item.word, item.lemma || item.word, langConfig.referenceLinks),
                        isMultiMeaning: true
                    };
                    flashcards.push(card);
                }

                if (flashcards.length === 0) {
                    alert('No flashcards found in this range. Please try another set.');
                    document.getElementById('loadingMessage').style.display = 'none';
                    return;
                }

                // Successfully loaded data - show cards and hide setup
                document.getElementById('setupPanel').classList.add('hidden');
                document.getElementById('appContent').classList.remove('hidden');
                document.getElementById('loadingMessage').style.display = 'none';

                // Initialize card display
                initializeApp();
            } catch (error) {
                console.error(`Failed to load vocabulary data:`, error);
                document.getElementById('loadingMessage').style.display = 'none';
                alert(`Error loading ${rangeString}. Please try another set.`);
            }
        }

        async function loadCSVFiles(ranges) {
            // Completely clear all previous data and state
            flashcards = [];
            currentIndex = 0;
            currentSentenceIndex = 0;
            currentMeaningIndex = 0;
            isFlipped = false;

            // Reset card flip state
            const flashcardEl = document.getElementById('flashcard');
            if (flashcardEl) {
                flashcardEl.classList.remove('flipped');
            }

            const langConfig = config.languages[selectedLanguage];

            for (const range of ranges) {
                try {
                    const response = await fetch(range.path);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    const fileText = await response.text();

                    // Extract starting and ending rank from range (e.g., "0-50" -> 0, 50)
                    const [rangeStart, rangeEnd] = range.range.split('-').map(Number);
                    const startRank = rangeStart;

                    // Check if this set uses the new multi-meaning format
                    if (range.format === 'multiMeaning' || fileText.includes('|')) {
                        parseMultiMeaning(fileText, langConfig, rangeStart, rangeEnd);
                    } else if (langConfig.fileFormat === 'quizlet') {
                        parseQuizlet(fileText, langConfig, startRank, rangeStart, rangeEnd);
                    } else {
                        parseCSV(fileText, langConfig, startRank, rangeStart, rangeEnd);
                    }
                } catch (error) {
                    console.error(`Failed to load ${range.path}:`, error);
                    document.getElementById('loadingMessage').style.display = 'none';
                    alert(`Error loading ${range.range}. Please try another set.`);
                    return;
                }
            }

            if (flashcards.length === 0) {
                alert('No flashcards loaded. Please check your selection.');
                document.getElementById('loadingMessage').style.display = 'none';
                return;
            }

            // Successfully loaded data - show cards and hide setup
            document.getElementById('setupPanel').classList.add('hidden');
            document.getElementById('appContent').classList.remove('hidden');
            document.getElementById('loadingMessage').style.display = 'none';

            // Initialize card display
            updateCard();
        }

        function parseMultiMeaning(text, langConfig, rangeStart, rangeEnd) {
            const lines = text.split('\n');
            const wordGroups = {}; // Group meanings by rank

            for (const line of lines) {
                const trimmed = line.trim();
                if (!trimmed) continue;

                const parts = trimmed.split('|');
                if (parts.length < 8) continue;

                const rank = parseInt(parts[0]);
                const word = parts[1];
                const lemma = parts[2];
                const pos = parts[3];
                const meaning = parts[4];
                const percentage = parseFloat(parts[5]);
                const targetSentence = parts[6];
                const englishSentence = parts[7];

                if (!wordGroups[rank]) {
                    wordGroups[rank] = {
                        rank: rank,
                        word: word,
                        lemma: lemma,
                        meanings: []
                    };
                }

                wordGroups[rank].meanings.push({
                    pos: pos,
                    meaning: meaning,
                    percentage: percentage,
                    targetSentence: targetSentence,
                    englishSentence: englishSentence
                });
            }

            // Convert to flashcards array, filtering by range
            const ranks = Object.keys(wordGroups).map(Number).sort((a, b) => a - b);

            for (const rank of ranks) {
                if (rank >= rangeStart && rank < rangeEnd) {
                    const group = wordGroups[rank];

                    // Sort meanings by percentage (highest first)
                    group.meanings.sort((a, b) => b.percentage - a.percentage);

                    // Normalize percentages if they're missing or sum to 0
                    const totalPercentage = group.meanings.reduce((sum, m) => sum + (m.percentage || 0), 0);
                    if (totalPercentage === 0 || isNaN(totalPercentage)) {
                        // Default to equal distribution
                        const equalPercentage = 1.0 / group.meanings.length;
                        group.meanings.forEach(m => {
                            m.percentage = equalPercentage;
                        });
                    } else if (totalPercentage !== 1.0) {
                        // Normalize to sum to 1.0
                        group.meanings.forEach(m => {
                            m.percentage = (m.percentage || 0) / totalPercentage;
                        });
                    }

                    const card = {
                        targetWord: group.word,
                        lemma: group.lemma,
                        rank: group.rank,
                        meanings: group.meanings,
                        // For compatibility, set primary translation to most common meaning
                        translation: group.meanings[0].meaning,
                        targetSentence: group.meanings[0].targetSentence,
                        englishSentence: group.meanings[0].englishSentence,
                        links: generateLinks(group.word, group.lemma || group.word, langConfig.referenceLinks),
                        isMultiMeaning: true
                    };

                    flashcards.push(card);
                }
            }

            document.getElementById('loadingMessage').textContent = `âœ“ Loaded ${flashcards.length} cards!`;
            setTimeout(() => {
                document.getElementById('setupPanel').style.display = 'none';
                document.getElementById('appContent').classList.remove('hidden');
                initializeApp();
            }, 500);
        }

        function parseQuizlet(text, langConfig, startRank = 0, rangeStart = 0, rangeEnd = Infinity) {
            const lines = text.split('\n');
            let i = 0;
            let cardCount = 0;
            let totalCardsParsed = 0; // Track position in file

            while (i < lines.length) {
                const line = lines[i].trim();

                // Skip empty lines
                if (!line) {
                    i++;
                    continue;
                }

                // First line: word and translation
                // Format: "word\ttranslation" or "*inflected* (base)\ttranslation"
                const parts = line.split('\t');
                if (parts.length < 2) {
                    i++;
                    continue;
                }

                let targetWord = parts[0].trim();
                let translation = parts[1].trim();

                // Extract base form if present (e.g., "*mala* (malo)" -> base: "malo", inflected: "mala")
                let baseForm = targetWord;
                let inflectedForm = null;

                // Check for inflected form pattern: *inflected* (base)
                const inflectedMatch = targetWord.match(/\*(.+?)\*\s*\((.+?)\)/);
                if (inflectedMatch) {
                    inflectedForm = inflectedMatch[1];
                    baseForm = inflectedMatch[2];
                    targetWord = inflectedForm;
                }

                // Remove asterisks from translation
                translation = translation.replace(/\*/g, '');

                // Next line should be the example sentence in target language
                i++;
                const targetSentence = (i < lines.length) ? lines[i].trim() : '';

                // Next line should be the English translation of the sentence
                i++;
                const englishSentence = (i < lines.length) ? lines[i].trim() : '';

                // Create the flashcard
                if (targetWord && translation) {
                    const currentRank = startRank + totalCardsParsed;

                    // Only include cards within the specified range
                    if (currentRank >= rangeStart && currentRank < rangeEnd) {
                        // Build sentences array - always include primary sentence and a placeholder for demo
                        const sentences = [];
                        if (targetSentence || englishSentence) {
                            sentences.push({ target: targetSentence, english: englishSentence });
                        }
                        // Add a placeholder second sentence to demonstrate swipe functionality
                        sentences.push({ target: '', english: '(Swipe up/down for more examples - coming soon!)' });

                        const card = {
                            targetWord: targetWord,
                            translation: translation,
                            baseForm: baseForm,
                            inflectedForm: inflectedForm,
                            targetSentence: targetSentence,
                            englishSentence: englishSentence,
                            sentences: sentences,
                            rank: currentRank + 1, // Calculate frequency rank
                            links: generateLinks(baseForm, baseForm, langConfig.referenceLinks)
                        };

                        flashcards.push(card);
                        cardCount++;
                    }
                    totalCardsParsed++;
                }

                // Move past empty lines between entries
                i++;
                while (i < lines.length && !lines[i].trim()) {
                    i++;
                }
            }
        }

        function parseCSV(csv, langConfig) {
            const lines = csv.split('\n');
            const headers = lines[0].split(',').map(h => h.trim());

            // Find column indices
            const wordIndex = headers.indexOf(langConfig.wordColumn);
            const sentenceIndex = headers.indexOf(langConfig.sentenceColumn);

            // Spanish-specific columns
            const showIndex = langConfig.showColumn ? headers.indexOf(langConfig.showColumn) : -1;
            const lemmaIndex = langConfig.lemmaColumn ? headers.indexOf(langConfig.lemmaColumn) : -1;

            // Dutch-specific columns
            const posIndex = langConfig.posColumn ? headers.indexOf(langConfig.posColumn) : -1;

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                // Handle quoted fields with commas
                const values = parseCSVLine(line);

                if (values.length > wordIndex) {
                    const word = cleanValue(values[wordIndex]);
                    const sentence = sentenceIndex >= 0 ? cleanValue(values[sentenceIndex]) : '';

                    if (!word) continue;

                    let card = {
                        word: word,
                        sentence: sentence
                    };

                    // Handle Spanish format
                    if (langConfig.csvFormat === 'spanish') {
                        card.show = showIndex >= 0 ? cleanValue(values[showIndex]) : word;
                        card.lemma = lemmaIndex >= 0 ? cleanValue(values[lemmaIndex]) : word;
                        card.links = generateLinks(word, card.lemma, langConfig.referenceLinks);
                    }
                    // Handle Dutch format
                    else if (langConfig.csvFormat === 'dutch') {
                        card.pos = posIndex >= 0 ? cleanValue(values[posIndex]) : '';
                        card.lemma = word;
                        card.links = generateLinks(word, word, langConfig.referenceLinks);
                    }

                    flashcards.push(card);
                }
            }
        }

        function parseCSVLine(line) {
            const values = [];
            let current = '';
            let inQuotes = false;

            for (let char of line) {
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            values.push(current);
            return values;
        }

        function cleanValue(value) {
            return value ? value.replace(/^"|"$/g, '').trim() : '';
        }

        function generateLinks(word, lemma, linkTemplates) {
            const cleanWord = encodeURIComponent(lemma || word);
            const links = {};

            for (const [key, template] of Object.entries(linkTemplates)) {
                links[key] = template.replace('{word}', cleanWord);
            }

            return links;
        }

        function initializeApp() {
            updateCard();
            updateStats();

            // Ensure modal is hidden on initialization
            document.getElementById('statsModal').classList.add('hidden');

            // Only set up event listeners once
            if (isAppInitialized) {
                return;
            }
            isAppInitialized = true;

            // Event listeners
            // Flip button on front
            document.getElementById('flipBtn').addEventListener('click', function(e) {
                e.stopPropagation();
                flipCard();
            });

            // Flip on back side
            document.getElementById('flashcard').addEventListener('click', function(e) {
                // Don't flip if clicking on buttons, links, or elements with onclick handlers
                if (e.target.closest('.nav-btn-inline') ||
                    e.target.closest('.link-btn') ||
                    e.target.closest('.card-action-small') ||
                    e.target.closest('.card-control-btn') ||
                    e.target.closest('#flipBtn') ||
                    e.target.closest('[onclick]')) {
                    return;
                }

                // Allow flipping anywhere else on the card (including front/back content)
                flipCard();
            });

            // Arrow buttons on the card faces
            document.getElementById('prevBtnFront').addEventListener('click', function(e) {
                e.stopPropagation();
                previousCard();
            });
            document.getElementById('nextBtnFront').addEventListener('click', function(e) {
                e.stopPropagation();
                nextCard();
            });
            document.getElementById('prevBtnBack').addEventListener('click', function(e) {
                e.stopPropagation();
                previousCard();
            });
            document.getElementById('nextBtnBack').addEventListener('click', function(e) {
                e.stopPropagation();
                nextCard();
            });
            // Top card buttons
            document.getElementById('reverseLangBtn').addEventListener('click', function(e) {
                e.stopPropagation();
                flipDirection();
            });
            document.getElementById('shuffleBtnTop').addEventListener('click', function(e) {
                e.stopPropagation();
                shuffleCards();
            });

            // Bottom right card buttons
            document.getElementById('backBtnSmall').addEventListener('click', function(e) {
                e.stopPropagation();
                goBackToSetup();
            });
            document.getElementById('statsBtnSmall').addEventListener('click', function(e) {
                e.stopPropagation();
                showStatsModal();
            });

            document.getElementById('closeStatsModal').addEventListener('click', hideStatsModal);

            // Click outside modal to close
            document.getElementById('statsModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    hideStatsModal();
                }
            });

            // Deck complete modal buttons
            document.getElementById('restartAllBtn').addEventListener('click', function() {
                hideDeckCompleteModal();
                restartAllCards();
            });

            document.getElementById('continueIncorrectBtn').addEventListener('click', function() {
                if (window.currentIncorrectCards && window.currentIncorrectCards.length > 0) {
                    hideDeckCompleteModal();
                    restartWithIncorrectCards(window.currentIncorrectCards);
                }
            });

            document.getElementById('markCompleteBtn').addEventListener('click', function() {
                hideDeckCompleteModal();
                // For now, just go back to setup (data storage not implemented)
                goBackToSetup();
            });

            // Click outside deck complete modal to close
            document.getElementById('deckCompleteModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    hideDeckCompleteModal();
                }
            });

            // Swipe gestures
            setupSwipeGestures();

            // Keyboard shortcuts
            setupKeyboardShortcuts();
        }

        function setupSwipeGestures() {
            const card = document.getElementById('flashcard');
            const incorrectIndicator = document.getElementById('incorrectIndicator');
            const correctIndicator = document.getElementById('correctIndicator');
            let touchStartX = 0;
            let touchStartY = 0;
            let currentX = 0;
            let currentY = 0;
            let isDragging = false;
            let hasMoved = false;
            let touchStartTime = 0;
            let maxMovement = 0; // Track maximum movement during touch
            let startedOnCircle = false; // Track if touch started on flip circle
            let touchZone = null; // Track which zone touch started in
            let wasFlippedAtStart = false; // Track flip state at touch start

            // Helper to determine touch zone (center vs edges)
            function getTouchZone(touchX, cardRect) {
                const relativeX = (touchX - cardRect.left) / cardRect.width;
                if (relativeX < 0.25) return 'left-edge';
                if (relativeX > 0.75) return 'right-edge';
                return 'center';
            }

            card.addEventListener('touchstart', function(e) {
                // Don't handle if touch is on buttons, links, or specific interactive elements
                if (e.target.closest('.nav-btn-inline') ||
                    e.target.closest('.link-btn') ||
                    e.target.closest('.card-control-btn') ||
                    e.target.closest('.card-action-small') ||
                    e.target.closest('.desktop-answer-btn') ||
                    e.target.closest('[onclick]')) {
                    return;
                }

                // Check if touch started on flip button or flip-back-area
                startedOnCircle = !!(e.target.closest('#flipBtn') || e.target.closest('.flip-back-area'));

                // Track flip state at start of touch
                wasFlippedAtStart = card.classList.contains('flipped');

                // Get touch zone for zone-based gesture handling
                const cardRect = card.getBoundingClientRect();
                touchZone = getTouchZone(e.touches[0].clientX, cardRect);

                // On back side, allow swiping from card-details area (remove the restriction)
                // Only block actual interactive elements like onclick handlers
                if (wasFlippedAtStart) {
                    // Back side: allow swipe from anywhere except buttons/links
                    // This enables swiping even from card-details area
                } else {
                    // Front side: standard handling
                    if (e.target.closest('.card-front') || e.target.closest('#flipBtn')) {
                        // Allow touch to proceed
                    } else {
                        return;
                    }
                }

                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                currentX = touchStartX;
                currentY = touchStartY;
                isDragging = true;
                hasMoved = false;
                maxMovement = 0;
                touchStartTime = Date.now();
                card.classList.add('swiping');
            }, { passive: true });

            card.addEventListener('touchmove', function(e) {
                if (!isDragging) return;

                currentX = e.touches[0].clientX;
                currentY = e.touches[0].clientY;

                const diffX = currentX - touchStartX;
                const diffY = currentY - touchStartY;
                const totalMovement = Math.abs(diffX) + Math.abs(diffY);
                maxMovement = Math.max(maxMovement, totalMovement);

                // Only mark as moved if significant movement (raised threshold)
                if (Math.abs(diffX) > 5 || Math.abs(diffY) > 5) {
                    hasMoved = true;
                }

                // Horizontal swipes - move card and show indicators
                if (Math.abs(diffX) > Math.abs(diffY) && hasMoved) {
                    const rotation = diffX / 20; // Rotate based on swipe distance

                    // Preserve flip state when moving card
                    const isFlipped = card.classList.contains('flipped');
                    if (isFlipped) {
                        card.style.transform = `translateX(${diffX}px) rotate(${rotation}deg) rotateY(180deg)`;
                    } else {
                        card.style.transform = `translateX(${diffX}px) rotate(${rotation}deg)`;
                    }

                    // Show indicators based on swipe direction
                    if (diffX > 50) {
                        correctIndicator.classList.add('visible');
                        incorrectIndicator.classList.remove('visible');
                    } else if (diffX < -50) {
                        incorrectIndicator.classList.add('visible');
                        correctIndicator.classList.remove('visible');
                    } else {
                        correctIndicator.classList.remove('visible');
                        incorrectIndicator.classList.remove('visible');
                    }
                }
            }, { passive: true });

            card.addEventListener('touchend', function(e) {
                if (!isDragging) return;
                isDragging = false;

                const diffX = currentX - touchStartX;
                const diffY = currentY - touchStartY;
                const touchDuration = Date.now() - touchStartTime;

                card.classList.remove('swiping');
                correctIndicator.classList.remove('visible');
                incorrectIndicator.classList.remove('visible');

                // Reset card transform
                card.style.transform = '';

                // Tap detection - very strict threshold
                const isTap = touchDuration < 200 && maxMovement < 7.5;
                const isQuickTap = touchDuration < 300 && maxMovement < 15;

                // ========== FRONT SIDE LOGIC (flip priority) ==========
                if (!wasFlippedAtStart) {
                    // If touch started on flip circle, only allow flipping
                    if (startedOnCircle) {
                        if (touchDuration < 500 && maxMovement < 100) {
                            flipCard();
                        }
                        return;
                    }

                    // Center zone: flip is priority, ignore swipes
                    if (touchZone === 'center') {
                        // Only flip on clear taps, not on any small movement
                        if (isTap || isQuickTap) {
                            flipCard();
                        }
                        // Any other movement is ignored (prevents accidental partial swipes)
                        return;
                    }

                    // Edge zones: swipe takes priority
                    const edgeSwipeThreshold = 5; // Reduced 75% from 20 for even easier swiping
                    const isEdgeSwipe = Math.abs(diffX) > edgeSwipeThreshold && Math.abs(diffX) > Math.abs(diffY);

                    if (isEdgeSwipe) {
                        handleSwipeAction(diffX > 0 ? 'correct' : 'incorrect');
                    } else if (isTap) {
                        flipCard(); // Tap on edge still flips
                    }
                    return;
                }

                // ========== BACK SIDE LOGIC (swipe priority) ==========
                const backSwipeThreshold = 5; // Reduced 75% from 20 for even easier swiping on back
                const isHorizontalSwipe = Math.abs(diffX) > backSwipeThreshold && Math.abs(diffX) > Math.abs(diffY) * 1.2;
                const isVerticalSwipe = Math.abs(diffY) > backSwipeThreshold && Math.abs(diffY) > Math.abs(diffX) * 1.2;

                if (isHorizontalSwipe) {
                    // Horizontal swipe - correct/incorrect
                    handleSwipeAction(diffX > 0 ? 'correct' : 'incorrect');
                } else if (isVerticalSwipe) {
                    // Vertical swipe - cycle through meanings for multi-meaning cards
                    const currentCard = flashcards[currentIndex];
                    if (currentCard && currentCard.isMultiMeaning) {
                        if (diffY < 0) {
                            currentMeaningIndex = (currentMeaningIndex + 1) % currentCard.meanings.length;
                        } else {
                            currentMeaningIndex = (currentMeaningIndex - 1 + currentCard.meanings.length) % currentCard.meanings.length;
                        }
                        updateCard();
                    } else if (currentCard && currentCard.sentences) {
                        if (diffY < 0) {
                            currentSentenceIndex = (currentSentenceIndex + 1) % currentCard.sentences.length;
                        } else {
                            currentSentenceIndex = (currentSentenceIndex - 1 + currentCard.sentences.length) % currentCard.sentences.length;
                        }
                        updateCard();
                    }
                } else if (startedOnCircle && maxMovement < 50) {
                    // Only flip back if specifically tapping the flip area
                    flipCard();
                }
                // Other gestures on back side are ignored (prevents accidental flips)
            }, { passive: true });
        }

        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', function(e) {
                // Ignore if typing in an input field
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }

                // Left arrow = incorrect
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    handleSwipeAction('incorrect');
                }
                // Right arrow = correct
                else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    handleSwipeAction('correct');
                }
                // Space or Enter = flip card
                else if (e.key === ' ' || e.key === 'Enter') {
                    e.preventDefault();
                    flipCard();
                }
            });
        }

        function handleSwipeAction(result) {
            const card = document.getElementById('flashcard');
            const isFlipped = card.classList.contains('flipped');

            // Record the result
            recordCardResult(result);

            // Animate the card off screen (maintain flip state during animation)
            if (result === 'correct') {
                card.classList.add('swipe-correct');
            } else {
                card.classList.add('swipe-incorrect');
            }

            // Wait for animation to complete, then move to next card
            setTimeout(() => {
                card.classList.remove('swipe-correct', 'swipe-incorrect');
                card.style.transform = '';

                // Move to next card
                if (currentIndex < flashcards.length - 1) {
                    currentIndex++;
                    currentSentenceIndex = 0; // Reset sentence index for new card
                    currentMeaningIndex = 0; // Reset meaning index for new card
                    updateCard();
                    // Always show front side of next card
                    document.getElementById('flashcard').classList.remove('flipped');
                } else {
                    // End of deck - show options
                    showEndOfDeckOptions();
                }
            }, 300);
        }

        function showEndOfDeckOptions() {
            const incorrectCards = Object.keys(stats.cardStats)
                .filter(idx => stats.cardStats[idx].incorrect > stats.cardStats[idx].correct)
                .map(Number);

            const totalAttempts = stats.correct + stats.incorrect;
            const accuracy = totalAttempts > 0 ? Math.round((stats.correct / totalAttempts) * 100) : 0;

            // Update modal content
            document.getElementById('completeCorrect').textContent = stats.correct;
            document.getElementById('completeIncorrect').textContent = stats.incorrect;
            document.getElementById('completeAccuracy').textContent = `Accuracy: ${accuracy}%`;

            const continueBtn = document.getElementById('continueIncorrectBtn');
            const messageEl = document.getElementById('completeMessage');

            if (incorrectCards.length > 0) {
                messageEl.textContent = `${incorrectCards.length} card${incorrectCards.length > 1 ? 's' : ''} to review`;
                continueBtn.disabled = false;
                continueBtn.querySelector('span:last-child').textContent = `Review ${incorrectCards.length} Mistake${incorrectCards.length > 1 ? 's' : ''}`;
            } else {
                messageEl.innerHTML = `<span style="color: var(--accent-green); font-weight: 600;">Perfect score! ðŸŽ‰</span>`;
                continueBtn.disabled = true;
                continueBtn.querySelector('span:last-child').textContent = 'No Mistakes';
            }

            // Store incorrect cards for later use
            window.currentIncorrectCards = incorrectCards;

            // Show the modal
            document.getElementById('deckCompleteModal').classList.remove('hidden');
        }

        function hideDeckCompleteModal() {
            document.getElementById('deckCompleteModal').classList.add('hidden');
        }

        function restartWithIncorrectCards(incorrectIndices) {
            // Create new deck with only incorrect cards
            const incorrectFlashcards = incorrectIndices.map(idx => flashcards[idx]);

            // Reset stats
            stats.correct = 0;
            stats.incorrect = 0;
            stats.total = 0;
            stats.studied = new Set();
            stats.cardStats = {};

            // Set new flashcards array
            flashcards = incorrectFlashcards;
            currentIndex = 0;
            currentSentenceIndex = 0;

            updateCard();
            document.getElementById('flashcard').classList.remove('flipped');
        }

        function restartAllCards() {
            // Reset stats
            stats.correct = 0;
            stats.incorrect = 0;
            stats.total = 0;
            stats.studied = new Set();
            stats.cardStats = {};

            currentIndex = 0;
            currentSentenceIndex = 0;

            updateCard();
            document.getElementById('flashcard').classList.remove('flipped');
        }

        function recordCardResult(result) {
            // Initialize card stats if not exists
            if (!stats.cardStats[currentIndex]) {
                stats.cardStats[currentIndex] = { correct: 0, incorrect: 0 };
            }

            // Record the result
            if (result === 'correct') {
                stats.correct++;
                stats.cardStats[currentIndex].correct++;
            } else {
                stats.incorrect++;
                stats.cardStats[currentIndex].incorrect++;
            }
            stats.total++;
        }

        function goBackToSetup() {
            // Hide app content, show setup
            const appContent = document.getElementById('appContent');
            const setupPanel = document.getElementById('setupPanel');

            appContent.classList.add('hidden');
            setupPanel.classList.remove('hidden');
            setupPanel.style.display = 'block';

            // Scroll to top
            document.querySelector('.container').scrollTop = 0;

            // Reset selections
            document.querySelectorAll('.range-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            document.querySelectorAll('.range-btn-new').forEach(btn => {
                btn.classList.remove('selected');
            });
            selectedRanges = [];
            flashcards = [];
            currentIndex = 0;
            currentSentenceIndex = 0;
            currentMeaningIndex = 0;
            isFlipped = false;

            // Reset card state
            const flashcardEl = document.getElementById('flashcard');
            if (flashcardEl) {
                flashcardEl.classList.remove('flipped');
            }

            stats = {
                studied: new Set(),
                correct: 0,
                incorrect: 0,
                total: 0,
                cardStats: {}
            };
        }

        function showStatsModal() {
            document.getElementById('statsModal').classList.remove('hidden');
            updateStatsModal();
        }

        function hideStatsModal() {
            document.getElementById('statsModal').classList.add('hidden');
        }


        function updateStatsModal() {
            document.getElementById('cardsStudied').textContent = stats.studied.size;
            document.getElementById('totalCardsStats').textContent = flashcards.length;
            const progress = flashcards.length > 0 ? Math.round((stats.studied.size / flashcards.length) * 100) : 0;
            document.getElementById('progressPercent').textContent = progress + '%';

            document.getElementById('correctCount').textContent = stats.correct;
            document.getElementById('incorrectCount').textContent = stats.incorrect;

            const totalAttempts = stats.correct + stats.incorrect;
            const accuracy = totalAttempts > 0 ? Math.round((stats.correct / totalAttempts) * 100) : 0;
            document.getElementById('accuracyPercent').textContent = totalAttempts > 0 ? accuracy + '%' : '-';
        }

        function updateCard() {
            const card = flashcards[currentIndex];
            const langConfig = config.languages[selectedLanguage];

            // Update reverse button text
            updateReverseButton();

            // Reset meaning index if out of bounds
            if (card.isMultiMeaning && currentMeaningIndex >= card.meanings.length) {
                currentMeaningIndex = 0;
            }

            // Get the current meaning for multi-meaning cards
            const currentMeaning = card.isMultiMeaning ? card.meanings[currentMeaningIndex] : null;

            // Determine what to show on front and back based on flip direction
            let frontText, backWord, backTranslation, exampleSentence, exampleTranslation;

            if (card.isMultiMeaning) {
                // Multi-meaning format
                if (isFlipped) {
                    // English â†’ Target language
                    frontText = currentMeaning.meaning;
                    backWord = card.targetWord;
                    backTranslation = currentMeaning.meaning;
                    exampleSentence = currentMeaning.englishSentence;
                    exampleTranslation = currentMeaning.targetSentence;
                } else {
                    // Target language â†’ English (normal)
                    frontText = card.targetWord;
                    backWord = card.targetWord;
                    backTranslation = currentMeaning.meaning;
                    exampleSentence = currentMeaning.targetSentence;
                    exampleTranslation = currentMeaning.englishSentence;
                }
            } else {
                // Legacy format - get current sentence from sentences array
                const currentSentence = card.sentences && card.sentences.length > 0
                    ? card.sentences[currentSentenceIndex % card.sentences.length]
                    : { target: card.targetSentence, english: card.englishSentence };

                if (isFlipped) {
                    // English â†’ Target language
                    frontText = card.translation;
                    backWord = card.targetWord;
                    backTranslation = card.translation;
                    exampleSentence = currentSentence.english;
                    exampleTranslation = currentSentence.target;
                } else {
                    // Target language â†’ English (normal)
                    frontText = card.targetWord;
                    backWord = card.targetWord;
                    backTranslation = card.translation;
                    exampleSentence = currentSentence.target;
                    exampleTranslation = currentSentence.english;
                }
            }

            document.getElementById('frontWord').textContent = frontText;

            // Display lemma on front if different from target word
            const frontLemmaEl = document.getElementById('frontLemma');
            if (card.lemma && card.lemma !== card.targetWord) {
                frontLemmaEl.textContent = card.lemma;
                frontLemmaEl.style.display = 'block';
            } else {
                frontLemmaEl.style.display = 'none';
            }

            // Store ranking as data attribute on card for console access
            const flashcardEl = document.getElementById('flashcard');
            if (card.rank !== undefined) {
                flashcardEl.setAttribute('data-rank', card.rank);
            } else {
                flashcardEl.setAttribute('data-rank', '');
            }

            // Display ranking on front card
            const frontRankingEl = document.getElementById('frontRanking');
            if (card.rank !== undefined) {
                frontRankingEl.textContent = `Rank: ${card.rank}`;
                frontRankingEl.style.display = 'block';
            } else {
                frontRankingEl.style.display = 'none';
            }

            // Build back content with lemma in brackets if different
            let wordDisplay = backWord;
            if (card.isMultiMeaning && card.lemma && card.lemma !== card.targetWord) {
                wordDisplay = `${backWord} <span style="color: var(--accent-secondary); font-size: 28px;">(${card.lemma})</span>`;
            }

            let backHTML = `
                <div style="text-align: center; margin-bottom: 20px;">
                    <div class="flip-back-area" id="flipBackArea">
                        <div style="font-size: 42px; color: var(--accent-primary); font-weight: bold;">${wordDisplay}</div>
                    </div>
                </div>
            `;

            // For multi-meaning cards, show all meanings on the back
            if (card.isMultiMeaning) {

                backHTML += `<div style="width: 100%; margin-bottom: 15px;">`;
                card.meanings.forEach((m, idx) => {
                    const isSelected = idx === currentMeaningIndex;
                    const bgColor = isSelected ? 'rgba(var(--accent-primary-rgb), 0.5)' : 'var(--bg-tertiary)';
                    const textColor = isSelected ? 'var(--text-primary)' : 'var(--text-primary)';
                    const borderStyle = isSelected ? 'border: 2px solid var(--accent-primary);' : '';
                    backHTML += `
                        <div style="display: flex; align-items: center; padding: 10px 15px; margin-bottom: 8px; background: ${bgColor}; ${borderStyle} border-radius: 8px; cursor: pointer;" onclick="selectMeaning(${idx})">
                            <span style="font-family: var(--font-data); font-size: 12px; color: ${isSelected ? 'var(--accent-secondary)' : 'var(--accent-secondary)'}; min-width: 45px;">${Math.round(m.percentage * 100)}%</span>
                            <span style="font-size: 16px; font-weight: 600; color: ${textColor}; flex: 1;">${m.meaning}</span>
                            <span style="font-family: var(--font-data); font-size: 11px; color: ${isSelected ? 'var(--text-secondary)' : 'var(--text-muted)'}; text-transform: uppercase;">${m.pos}</span>
                        </div>
                    `;
                });
                backHTML += `</div>`;

                // Show current sentence
                if (currentMeaning && currentMeaning.targetSentence) {
                    backHTML += `
                        <div class="sentence" style="text-align: center;">
                            <div style="margin-bottom: 8px;">${currentMeaning.targetSentence}</div>
                            <div class="translation">${currentMeaning.englishSentence}</div>
                        </div>
                    `;
                }
            } else {
                // Legacy format
                backHTML += `<div style="font-size: 28px; color: var(--text-primary); margin-top: 12px; font-weight: 600; text-align: center; margin-bottom: 20px;">${backTranslation}</div>`;

                // Show base form if different from displayed word
                if (card.inflectedForm && card.baseForm !== card.targetWord) {
                    backHTML += `<div style="margin-bottom: 15px; font-size: 16px; text-align: center; color: #ffffff;"><strong style="color: var(--accent-secondary);">Base form:</strong> ${card.baseForm}</div>`;
                }

                // Show example sentences if available
                const sentenceCount = card.sentences ? card.sentences.length : 1;
                if (sentenceCount > 0) {
                    const showEmpty = !exampleSentence && !exampleTranslation;
                    const sentenceIndicator = sentenceCount > 1 ? `
                        <div style="display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 8px;">
                            <span style="color: var(--accent-primary); font-size: 18px;">â†‘</span>
                            <span style="color: var(--text-muted); font-size: 12px;">${currentSentenceIndex + 1} / ${sentenceCount}</span>
                            <span style="color: var(--accent-primary); font-size: 18px;">â†“</span>
                        </div>
                    ` : '';

                    backHTML += `
                        ${sentenceIndicator}
                        <div class="sentence" style="min-height: 80px; text-align: center;">
                            ${exampleSentence ? `<div style="margin-bottom: 8px;">${exampleSentence}</div>` : ''}
                            ${exampleTranslation ? `<div class="translation">${exampleTranslation}</div>` : ''}
                            ${showEmpty ? `<div style="color: var(--text-muted); text-align: center; padding: 20px;">(No example sentence)</div>` : ''}
                        </div>
                    `;
                }
            }

            // Reference links (exclude wordReference, use shortened labels)
            const linkLabels = {
                'spanishDict': 'SpanishDict',
                'reverso': 'Reverso',
                'conjugation': 'Conjugate'
            };

            // Determine if current word is a verb
            let isVerb = false;
            if (card.isMultiMeaning && currentMeaning) {
                // For multi-meaning cards, check the current meaning's POS
                const pos = currentMeaning.pos ? currentMeaning.pos.toLowerCase() : '';
                isVerb = pos.includes('verb') || pos === 'v' || pos === 'vb';
            }

            backHTML += `<div class="links-section" id="linksSection">`;

            for (const [key, url] of Object.entries(card.links)) {
                if (key === 'wordReference') continue; // Skip wordReference
                // Skip conjugation link for non-verbs
                if (key === 'conjugation' && !isVerb) continue;
                const label = linkLabels[key] || key;
                backHTML += `<a href="${url}" target="_blank" class="link-btn">${label}</a>`;
            }

            backHTML += `</div>`;

            document.getElementById('backContent').innerHTML = backHTML;

            // Update frequency display
            stats.studied.add(currentIndex);
            updateStats();

            // Update disabled state for all nav buttons
            const isPrevDisabled = currentIndex === 0;
            const isNextDisabled = currentIndex === flashcards.length - 1;
            document.getElementById('prevBtnFront').disabled = isPrevDisabled;
            document.getElementById('nextBtnFront').disabled = isNextDisabled;
            document.getElementById('prevBtnBack').disabled = isPrevDisabled;
            document.getElementById('nextBtnBack').disabled = isNextDisabled;

            // Setup top answer buttons (desktop only)
            const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
            if (!isTouchDevice) {
                const correctBtnTop = document.getElementById('correctBtnTop');
                const incorrectBtnTop = document.getElementById('incorrectBtnTop');

                if (correctBtnTop && incorrectBtnTop) {
                    correctBtnTop.style.display = 'flex';
                    incorrectBtnTop.style.display = 'flex';

                    correctBtnTop.onclick = function(e) {
                        e.stopPropagation();
                        handleSwipeAction('correct');
                    };
                    incorrectBtnTop.onclick = function(e) {
                        e.stopPropagation();
                        handleSwipeAction('incorrect');
                    };
                }
            }
        }

        function flipCard() {
            document.getElementById('flashcard').classList.toggle('flipped');
        }

        function selectMeaning(index) {
            currentMeaningIndex = index;
            updateCard();
        }

        function previousCard() {
            if (currentIndex > 0) {
                currentIndex--;
                currentMeaningIndex = 0; // Reset meaning selection
                updateCard();
                document.getElementById('flashcard').classList.remove('flipped');
            }
        }

        function nextCard() {
            if (currentIndex < flashcards.length - 1) {
                currentIndex++;
                currentMeaningIndex = 0; // Reset meaning selection
                updateCard();
                document.getElementById('flashcard').classList.remove('flipped');
            }
        }

        function shuffleCards() {
            for (let i = flashcards.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [flashcards[i], flashcards[j]] = [flashcards[j], flashcards[i]];
            }
            currentIndex = 0;
            updateCard();
        }

        function flipDirection() {
            isFlipped = !isFlipped;
            updateCard();
            document.getElementById('flashcard').classList.remove('flipped');
        }

        function updateReverseButton() {
            const reverseBtn = document.getElementById('reverseLangBtn');
            if (!reverseBtn) return;

            // Map language codes to flag emojis
            const flagMap = {
                'dutch': 'ðŸ‡³ðŸ‡±',
                'polish': 'ðŸ‡µðŸ‡±',
                'spanish': 'ðŸ‡ªðŸ‡¸',
                'italian': 'ðŸ‡®ðŸ‡¹',
                'french': 'ðŸ‡«ðŸ‡·',
                'russian': 'ðŸ‡·ðŸ‡º',
                'swedish': 'ðŸ‡¸ðŸ‡ª'
            };

            const targetFlag = flagMap[selectedLanguage] || 'ðŸ‡¸ðŸ‡ª';
            const englishFlag = 'ðŸ‡¬ðŸ‡§';

            if (isFlipped) {
                // English â†’ Target language
                reverseBtn.innerHTML = `${englishFlag} â†’ ${targetFlag}`;
                reverseBtn.title = `Reverse to ${config.languages[selectedLanguage]?.name || selectedLanguage} â†’ English`;
            } else {
                // Target language â†’ English (normal)
                reverseBtn.innerHTML = `${targetFlag} â†’ ${englishFlag}`;
                reverseBtn.title = `Reverse to English â†’ ${config.languages[selectedLanguage]?.name || selectedLanguage}`;
            }
        }

        function updateStats() {
            // Stats are now displayed in modal only
        }
    </script>
</body>
</html>